/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$isTextNode as e,$getCharacterOffsets as t,$isElementNode as n,$isRootNode as l,$getNodeByKey as o,$getPreviousSelection as r,$createTextNode as s,$isRangeSelection as i,$isTokenOrSegmented as c,$getRoot as f,$isRootOrShadowRoot as u,$hasAncestor as g,$isLeafNode as a,$setSelection as d,$getAdjacentNode as p,$isDecoratorNode as h,$isLineBreakNode as y}from"lexical";export{$cloneWithProperties}from"lexical";function m(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var T=m((function(e){const t=new URLSearchParams;t.append("code",e);for(let e=1;e<arguments.length;e++)t.append("v",arguments[e]);throw Error(`Minified Lexical error #${e}; visit https://lexical.dev/docs/error?${t} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const x=new Map;function S(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function v(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function C(t,n,l,o,r){const s=n.getKey(),i=o.getKey(),c=document.createRange();let f=t.getElementByKey(s),u=t.getElementByKey(i),g=l,a=r;if(e(n)&&(f=S(f)),e(o)&&(u=S(u)),void 0===n||void 0===o||null===f||null===u)return null;"BR"===f.nodeName&&([f,g]=v(f)),"BR"===u.nodeName&&([u,a]=v(u));const d=f.firstChild;f===u&&null!=d&&"BR"===d.nodeName&&0===g&&0===a&&(a=1);try{c.setStart(f,g),c.setEnd(u,a)}catch(e){return null}return!c.collapsed||g===a&&s===i||(c.setStart(u,a),c.setEnd(f,g)),c}function P(e,t){const n=e.getRootElement();if(null===n)return[];const l=n.getBoundingClientRect(),o=getComputedStyle(n),r=parseFloat(o.paddingLeft)+parseFloat(o.paddingRight),s=Array.from(t.getClientRects());let i,c=s.length;s.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=s[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,o=t.width+r===l.width;n||o?(s.splice(e--,1),c--):i=t}return s}function w(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,l]=e.split(/:([^]+)/);n&&l&&(t[n.trim()]=l.trim())}return t}function N(e){let t=x.get(e);return void 0===t&&(t=w(e),x.set(e,t)),t}function E(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function F(e,n){const l=e.getStartEndPoints();if(n.isSelected(e)&&!n.isSegmented()&&!n.isToken()&&null!==l){const[o,r]=l,s=e.isBackward(),i=o.getNode(),c=r.getNode(),f=n.is(i),u=n.is(c);if(f||u){const[l,o]=t(e),r=i.is(c),f=n.is(s?c:i),u=n.is(s?i:c);let g,a=0;if(r)a=l>o?o:l,g=l>o?l:o;else if(f){a=s?o:l,g=void 0}else if(u){a=0,g=s?l:o}return n.__text=n.__text.slice(a,g),n}}return n}function K(e){if("text"===e.type)return e.offset===e.getNode().getTextContentSize();const t=e.getNode();return n(t)||T(177),e.offset===t.getChildrenSize()}function I(t,c,f){let u=c.getNode(),g=f;if(n(u)){const e=u.getDescendantByIndex(c.offset);null!==e&&(u=e)}for(;g>0&&null!==u;){if(n(u)){const e=u.getLastDescendant();null!==e&&(u=e)}let f=u.getPreviousSibling(),a=0;if(null===f){let e=u.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){f=null;break}t=e.getPreviousSibling()}null!==e&&(a=e.isInline()?0:2,f=t)}let d=u.getTextContent();""===d&&n(u)&&!u.isInline()&&(d="\n\n");const p=d.length;if(!e(u)||g>=p){const e=u.getParent();u.remove(),null==e||0!==e.getChildrenSize()||l(e)||e.remove(),g-=p+a,u=f}else{const n=u.getKey(),l=t.getEditorState().read((()=>{const t=o(n);return e(t)&&t.isSimpleText()?t.getTextContent():null})),f=p-g,a=d.slice(0,f);if(null!==l&&l!==d){const e=r();let t=u;if(u.isSimpleText())u.setTextContent(l);else{const e=s(l);u.replace(e),t=e}if(i(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(u.isSimpleText()){const e=c.key===n;let t=c.offset;t<g&&(t=p);const l=e?t-g:0,o=e?t:f;if(e&&0===l){const[e]=u.splitText(l,o);e.remove()}else{const[,e]=u.splitText(l,o);e.remove()}}else{const e=s(a);u.replace(e)}g=0}}}function O(e){const t=e.getStyle(),n=w(t);x.set(t,n)}function B(e,t){const n=N("getStyle"in e?e.getStyle():e.style),l=Object.entries(t).reduce(((t,[l,o])=>("function"==typeof o?t[l]=o(n[l],e):null===o?delete t[l]:t[l]=o,t)),{...n}||{}),o=E(l);e.setStyle(o),x.set(o,l)}function k(t,n){const l=t.getNodes(),o=l.length,r=t.getStartEndPoints();if(null===r)return;const[s,f]=r,u=o-1;let g=l[0],a=l[u];if(t.isCollapsed()&&i(t))return void B(t,n);const d=g.getTextContent().length,p=f.offset;let h=s.offset;const y=s.isBefore(f);let m=y?h:p,T=y?p:h;const x=y?s.type:f.type,S=y?f.type:s.type,v=y?f.key:s.key;if(e(g)&&m===d){const t=g.getNextSibling();e(t)&&(h=0,m=0,g=t)}if(1===l.length){if(e(g)&&g.canHaveFormat()){if(m="element"===x?0:h>p?p:h,T="element"===S?d:h>p?h:p,m===T)return;if(c(g)||0===m&&T===d)B(g,n),g.select(m,T);else{const e=g.splitText(m,T),t=0===m?e[0]:e[1];B(t,n),t.select(0,T-m)}}}else{if(e(g)&&m<g.getTextContentSize()&&g.canHaveFormat()&&(0===m||c(g)||(g=g.splitText(m)[1],m=0,y?s.set(g.getKey(),m,"text"):f.set(g.getKey(),m,"text")),B(g,n)),e(a)&&a.canHaveFormat()){const e=a.getTextContent().length;a.__key!==v&&0!==T&&(T=e),T===e||c(a)||([a]=a.splitText(T)),0===T&&"element"!==S||B(a,n)}for(let t=1;t<u;t++){const o=l[t],r=o.getKey();e(o)&&o.canHaveFormat()&&r!==g.getKey()&&r!==a.getKey()&&!o.isToken()&&B(o,n)}}}function b(e,t){if(null===e)return;const l=e.getStartEndPoints(),o=l?l[0]:null;if(null!==o&&"root"===o.key){const e=t(),n=f(),l=n.getFirstChild();return void(l?l.replace(e,!0):n.append(e))}const r=e.getNodes(),s=null!==o&&function(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}(o.getNode(),W);s&&-1===r.indexOf(s)&&r.push(s);for(let e=0;e<r.length;e++){const l=r[e];if(!W(l))continue;n(l)||T(178);const o=t();o.setFormat(l.getFormatType()),o.setIndent(l.getIndent()),l.replace(o,!0)}}function R(e){return e.getNode().isAttached()}function _(e){let t=e;for(;null!==t&&!u(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function z(e,t,n=null){const l=e.getStartEndPoints(),o=l?l[0]:null,r=e.getNodes(),s=r.length;if(null!==o&&(0===s||1===s&&"element"===o.type&&0===o.getNode().getChildrenSize())){const e="text"===o.type?o.getNode().getParentOrThrow():o.getNode(),l=e.getChildren();let r=t();return r.setFormat(e.getFormatType()),r.setIndent(e.getIndent()),l.forEach((e=>r.append(e))),n&&(r=n.append(r)),void e.replace(r)}let i=null,c=[];for(let l=0;l<s;l++){const o=r[l];u(o)?(A(e,c,c.length,t,n),c=[],i=o):null===i||null!==i&&g(o,i)?c.push(o):(A(e,c,c.length,t,n),c=[o])}A(e,c,c.length,t,n)}function A(e,t,l,o,s=null){if(0===t.length)return;const c=t[0],f=new Map,g=[];let p=n(c)?c:c.getParentOrThrow();p.isInline()&&(p=p.getParentOrThrow());let h=!1;for(;null!==p;){const e=p.getPreviousSibling();if(null!==e){p=e,h=!0;break}if(p=p.getParentOrThrow(),u(p))break}const y=new Set;for(let e=0;e<l;e++){const l=t[e];n(l)&&0===l.getChildrenSize()&&y.add(l.getKey())}const m=new Set;for(let e=0;e<l;e++){const l=t[e];let r=l.getParent();if(null!==r&&r.isInline()&&(r=r.getParent()),null!==r&&a(l)&&!m.has(l.getKey())){const e=r.getKey();if(void 0===f.get(e)){const t=o();t.setFormat(r.getFormatType()),t.setIndent(r.getIndent()),g.push(t),f.set(e,t),r.getChildren().forEach((e=>{t.append(e),m.add(e.getKey()),n(e)&&e.getChildrenKeys().forEach((e=>m.add(e)))})),_(r)}}else if(y.has(l.getKey())){n(l)||T(179);const e=o();e.setFormat(l.getFormatType()),e.setIndent(l.getIndent()),g.push(e),l.remove(!0)}}if(null!==s)for(let e=0;e<g.length;e++){const t=g[e];s.append(t)}let x=null;if(u(p))if(h)if(null!==s)p.insertAfter(s);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t)}else{const e=p.getFirstChild();if(n(e)&&(p=e),null===e)if(s)p.append(s);else for(let e=0;e<g.length;e++){const t=g[e];p.append(t),x=t}else if(null!==s)e.insertBefore(s);else for(let t=0;t<g.length;t++){const n=g[t];e.insertBefore(n),x=n}}else if(s)p.insertAfter(s);else for(let e=g.length-1;e>=0;e--){const t=g[e];p.insertAfter(t),x=t}const S=r();i(S)&&R(S.anchor)&&R(S.focus)?d(S.clone()):null!==x?x.selectEnd():e.dirty=!0}function L(e,t){const l=p(e.focus,t);return h(l)&&!l.isIsolated()||n(l)&&!l.isInline()&&!l.canBeEmpty()}function D(e,t,n,l){e.modify(t?"extend":"move",n,l)}function M(e){const t=e.anchor.getNode();return"rtl"===(l(t)?t:t.getParentOrThrow()).getDirection()}function $(e,t,n){const l=M(e);D(e,t,n?!l:l,"character")}function H(t){const l=t.anchor,o=t.focus,r=l.getNode().getTopLevelElementOrThrow().getParentOrThrow();let s=r.getFirstDescendant(),i=r.getLastDescendant(),c="element",f="element",u=0;e(s)?c="text":n(s)||null===s||(s=s.getParentOrThrow()),e(i)?(f="text",u=i.getTextContentSize()):n(i)||null===i||(i=i.getParentOrThrow()),s&&i&&(l.set(s.getKey(),0,c),o.set(i.getKey(),u,f))}function j(e,t,n){const l=N(e.getStyle());return null!==l&&l[t]||n}function U(t,n,l=""){let o=null;const r=t.getNodes(),s=t.anchor,c=t.focus,f=t.isBackward(),u=f?c.offset:s.offset,g=f?c.getNode():s.getNode();if(i(t)&&t.isCollapsed()&&""!==t.style){const e=N(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const s=r[t];if((0===t||0!==u||!s.is(g))&&e(s)){const e=j(s,n,l);if(null===o)o=e;else if(o!==e){o="";break}}}return null===o?l:o}function W(t){if(h(t))return!1;if(!n(t)||u(t))return!1;const l=t.getFirstChild(),o=null===l||y(l)||e(l)||l.isInline();return!t.isInline()&&!1!==t.canBeEmpty()&&o}const X=I;export{O as $addNodeStyle,U as $getSelectionStyleValueForProperty,K as $isAtNodeEnd,M as $isParentElementRTL,D as $moveCaretSelection,$ as $moveCharacter,k as $patchStyleText,H as $selectAll,b as $setBlocksType,L as $shouldOverrideDefaultCharacterSelection,F as $sliceSelectedTextNodeContent,I as $trimTextContentFromAnchor,z as $wrapNodes,C as createDOMRange,P as createRectsFromDOMRange,E as getCSSFromStyleObject,N as getStyleObjectFromCSS,X as trimTextContentFromAnchor};
