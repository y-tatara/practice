"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  builder: () => builder,
  default: () => index_default,
  generateZod: () => generateZod,
  generateZodValidationSchemaDefinition: () => generateZodValidationSchemaDefinition,
  getZodDependencies: () => getZodDependencies,
  parseZodValidationSchemaDefinition: () => parseZodValidationSchemaDefinition
});
module.exports = __toCommonJS(index_exports);
var import_core2 = require("@orval/core");

// src/compatibleV4.ts
var import_core = require("@orval/core");
var getZodPackageVersion = (packageJson) => {
  var _a, _b, _c, _d, _e;
  return (_e = (_c = (_a = packageJson.dependencies) == null ? void 0 : _a["zod"]) != null ? _c : (_b = packageJson.devDependencies) == null ? void 0 : _b["zod"]) != null ? _e : (_d = packageJson.peerDependencies) == null ? void 0 : _d["zod"];
};
var isZodVersionV4 = (packageJson) => {
  const version = getZodPackageVersion(packageJson);
  if (!version) {
    return false;
  }
  const withoutRc = version.split("-")[0];
  return (0, import_core.compareVersions)(withoutRc, "4.0.0");
};
var getZodDateFormat = (isZodV4) => {
  return isZodV4 ? "iso.date" : "date";
};
var getZodTimeFormat = (isZodV4) => {
  return isZodV4 ? "iso.time" : "time";
};
var getZodDateTimeFormat = (isZodV4) => {
  return isZodV4 ? "iso.datetime" : "datetime";
};
var getParameterFunctions = (isZodV4, strict, parameters) => {
  if (isZodV4 && strict) {
    return [["strictObject", parameters]];
  } else {
    return strict ? [
      ["object", parameters],
      ["strict", void 0]
    ] : [["object", parameters]];
  }
};
var getObjectFunctionName = (isZodV4, strict) => {
  return isZodV4 && strict ? "strictObject" : "object";
};

// src/index.ts
var import_lodash = __toESM(require("lodash.uniq"));
var ZOD_DEPENDENCIES = [
  {
    exports: [
      {
        name: "z",
        alias: "zod",
        values: true
      }
    ],
    dependency: "zod"
  }
];
var getZodDependencies = () => ZOD_DEPENDENCIES;
var possibleSchemaTypes = [
  "integer",
  "number",
  "string",
  "boolean",
  "object",
  "strictObject",
  "null",
  "array"
];
var resolveZodType = (schema) => {
  const schemaTypeValue = schema.type;
  const type = Array.isArray(schemaTypeValue) ? schemaTypeValue.find((t) => possibleSchemaTypes.includes(t)) : schemaTypeValue;
  if (schema.type === "array" && "prefixItems" in schema) {
    return "tuple";
  }
  switch (type) {
    case "integer":
      return "number";
    default:
      return type != null ? type : "any";
  }
};
var constsUniqueCounter = {};
var COERCIBLE_TYPES = ["string", "number", "boolean", "bigint", "date"];
var minAndMaxTypes = ["number", "string", "array"];
var removeReadOnlyProperties = (schema) => {
  if (schema.properties) {
    return {
      ...schema,
      properties: Object.entries(schema.properties).reduce((acc, [key, value]) => {
        if ("readOnly" in value && value.readOnly) return acc;
        acc[key] = value;
        return acc;
      }, {})
    };
  }
  if (schema.items && "properties" in schema.items) {
    return {
      ...schema,
      items: removeReadOnlyProperties(schema.items)
    };
  }
  return schema;
};
var generateZodValidationSchemaDefinition = (schema, context, name, strict, isZodV4, rules) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  if (!schema) return { functions: [], consts: [] };
  const consts = [];
  const constsCounter = typeof constsUniqueCounter[name] === "number" ? constsUniqueCounter[name] + 1 : 0;
  const constsCounterValue = constsCounter ? (0, import_core2.pascal)((0, import_core2.getNumberWord)(constsCounter)) : "";
  constsUniqueCounter[name] = constsCounter;
  const functions = [];
  const type = resolveZodType(schema);
  const required = (_a = rules == null ? void 0 : rules.required) != null ? _a : false;
  const nullable = "nullable" in schema && schema.nullable || Array.isArray(schema.type) && schema.type.includes("null");
  const min = (_c = (_b = schema.minimum) != null ? _b : schema.minLength) != null ? _c : schema.minItems;
  const max = (_e = (_d = schema.maximum) != null ? _d : schema.maxLength) != null ? _e : schema.maxItems;
  const matches = (_f = schema.pattern) != null ? _f : void 0;
  let defaultVarName;
  if (schema.default !== void 0) {
    defaultVarName = `${name}Default${constsCounterValue}`;
    let defaultValue;
    const isDateType = schema.type === "string" && (schema.format === "date" || schema.format === "date-time") && context.output.override.useDates;
    if (isDateType) {
      defaultValue = `new Date("${(0, import_core2.escape)(schema.default)}")`;
    } else if ((0, import_core2.isObject)(schema.default)) {
      const entries = Object.entries(schema.default).map(([key, value]) => {
        if ((0, import_core2.isString)(value)) {
          return `${key}: "${(0, import_core2.escape)(value)}"`;
        }
        if (Array.isArray(value)) {
          const arrayItems = value.map(
            (item) => (0, import_core2.isString)(item) ? `"${(0, import_core2.escape)(item)}"` : `${item}`
          );
          return `${key}: [${arrayItems.join(", ")}]`;
        }
        return `${key}: ${value}`;
      }).join(", ");
      defaultValue = `{ ${entries} }`;
    } else {
      const rawStringified = (0, import_core2.stringify)(schema.default);
      defaultValue = rawStringified === void 0 ? "null" : rawStringified.replace(/'/g, '"');
    }
    consts.push(`export const ${defaultVarName} = ${defaultValue};`);
  }
  switch (type) {
    case "tuple":
      if ("prefixItems" in schema) {
        const schema31 = schema;
        if (schema31.prefixItems && schema31.prefixItems.length > 0) {
          functions.push([
            "tuple",
            schema31.prefixItems.map(
              (item, idx) => generateZodValidationSchemaDefinition(
                deference(item, context),
                context,
                (0, import_core2.camel)(`${name}-${idx}-item`),
                isZodV4,
                strict,
                {
                  required: true
                }
              )
            )
          ]);
          if (schema.items) {
            if ((max || Number.POSITIVE_INFINITY) > schema31.prefixItems.length) {
              functions.push([
                "rest",
                generateZodValidationSchemaDefinition(
                  schema.items,
                  context,
                  (0, import_core2.camel)(`${name}-item`),
                  strict,
                  isZodV4,
                  {
                    required: true
                  }
                )
              ]);
            }
          }
        }
      }
      break;
    case "array":
      functions.push([
        "array",
        generateZodValidationSchemaDefinition(
          schema.items,
          context,
          (0, import_core2.camel)(`${name}-item`),
          strict,
          isZodV4,
          {
            required: true
          }
        )
      ]);
      break;
    case "string": {
      if (schema.enum && type === "string") {
        break;
      }
      if (context.output.override.useDates && (schema.format === "date" || schema.format === "date-time")) {
        const formatAPI = getZodDateFormat(isZodV4);
        functions.push([formatAPI, void 0]);
        break;
      }
      if (schema.format === "binary") {
        functions.push(["instanceof", "File"]);
        break;
      }
      if (isZodV4) {
        if (![
          "date",
          "time",
          "date-time",
          "email",
          "uri",
          "hostname",
          "uuid"
        ].includes(schema.format || "")) {
          if ("const" in schema) {
            functions.push(["literal", `"${schema.const}"`]);
          } else {
            functions.push([type, void 0]);
          }
          break;
        }
      } else {
        if ("const" in schema) {
          functions.push(["literal", `"${schema.const}"`]);
        } else {
          functions.push([type, void 0]);
        }
      }
      if (schema.format === "date") {
        const formatAPI = getZodDateFormat(isZodV4);
        functions.push([formatAPI, void 0]);
        break;
      }
      if (schema.format === "time") {
        const options = (_g = context.output.override.zod) == null ? void 0 : _g.timeOptions;
        const formatAPI = getZodTimeFormat(isZodV4);
        functions.push([
          formatAPI,
          options ? JSON.stringify(options) : void 0
        ]);
        break;
      }
      if (schema.format === "date-time") {
        const options = (_h = context.output.override.zod) == null ? void 0 : _h.dateTimeOptions;
        const formatAPI = getZodDateTimeFormat(isZodV4);
        functions.push([
          formatAPI,
          options ? JSON.stringify(options) : void 0
        ]);
        break;
      }
      if (schema.format === "email") {
        functions.push(["email", void 0]);
        break;
      }
      if (schema.format === "uri" || schema.format === "hostname") {
        functions.push(["url", void 0]);
        break;
      }
      if (schema.format === "uuid") {
        functions.push(["uuid", void 0]);
        break;
      }
      break;
    }
    case "object":
    default: {
      if (schema.allOf || schema.oneOf || schema.anyOf) {
        const separator = schema.allOf ? "allOf" : schema.oneOf ? "oneOf" : "anyOf";
        const schemas = (_j = (_i = schema.allOf) != null ? _i : schema.oneOf) != null ? _j : schema.anyOf;
        functions.push([
          separator,
          schemas.map(
            (schema2) => generateZodValidationSchemaDefinition(
              schema2,
              context,
              (0, import_core2.camel)(name),
              strict,
              isZodV4,
              {
                required: true
              }
            )
          )
        ]);
        break;
      }
      if (schema.properties) {
        const objectType = getObjectFunctionName(isZodV4, strict);
        functions.push([
          objectType,
          Object.keys(schema.properties).map((key) => {
            var _a2, _b2;
            return {
              [key]: generateZodValidationSchemaDefinition(
                (_a2 = schema.properties) == null ? void 0 : _a2[key],
                context,
                (0, import_core2.camel)(`${name}-${key}`),
                strict,
                isZodV4,
                {
                  required: (_b2 = schema.required) == null ? void 0 : _b2.includes(key)
                }
              )
            };
          }).reduce((acc, curr) => ({ ...acc, ...curr }), {})
        ]);
        if (strict && !isZodV4) {
          functions.push(["strict", void 0]);
        }
        break;
      }
      if (schema.additionalProperties) {
        functions.push([
          "additionalProperties",
          generateZodValidationSchemaDefinition(
            (0, import_core2.isBoolean)(schema.additionalProperties) ? {} : schema.additionalProperties,
            context,
            name,
            strict,
            isZodV4,
            {
              required: true
            }
          )
        ]);
        break;
      }
      if (schema.enum) {
        break;
      }
      functions.push([type, void 0]);
      break;
    }
  }
  if (minAndMaxTypes.includes(type)) {
    if (min !== void 0) {
      if (min === 1) {
        functions.push(["min", `${min}`]);
      } else {
        consts.push(`export const ${name}Min${constsCounterValue} = ${min};
`);
        functions.push(["min", `${name}Min${constsCounterValue}`]);
      }
    }
    if (max !== void 0) {
      consts.push(`export const ${name}Max${constsCounterValue} = ${max};
`);
      functions.push(["max", `${name}Max${constsCounterValue}`]);
    }
  }
  if (matches) {
    const isStartWithSlash = matches.startsWith("/");
    const isEndWithSlash = matches.endsWith("/");
    const regexp = `new RegExp('${(0, import_core2.jsStringEscape)(
      matches.slice(isStartWithSlash ? 1 : 0, isEndWithSlash ? -1 : void 0)
    )}')`;
    consts.push(
      `export const ${name}RegExp${constsCounterValue} = ${regexp};
`
    );
    functions.push(["regex", `${name}RegExp${constsCounterValue}`]);
  }
  if (schema.enum) {
    if (schema.enum.every((value) => (0, import_core2.isString)(value))) {
      functions.push([
        "enum",
        `[${schema.enum.map((value) => `'${(0, import_core2.escape)(value)}'`).join(", ")}]`
      ]);
    } else {
      functions.push([
        "oneOf",
        schema.enum.map((value) => ({
          functions: [
            ["literal", (0, import_core2.isString)(value) ? `'${(0, import_core2.escape)(value)}'` : value]
          ],
          consts: []
        }))
      ]);
    }
  }
  if (!required && schema.default) {
    functions.push(["default", defaultVarName]);
  } else if (!required && nullable) {
    functions.push(["nullish", void 0]);
  } else if (nullable) {
    functions.push(["nullable", void 0]);
  } else if (!required) {
    functions.push(["optional", void 0]);
  }
  if (schema.description) {
    functions.push(["describe", `'${(0, import_core2.jsStringEscape)(schema.description)}'`]);
  }
  return { functions, consts: (0, import_lodash.default)(consts) };
};
var parseZodValidationSchemaDefinition = (input, context, coerceTypes = false, strict, isZodV4, preprocess) => {
  if (!input.functions.length) {
    return { zod: "", consts: "" };
  }
  let consts = "";
  const parseProperty = (property) => {
    const [fn, args = ""] = property;
    if (fn === "allOf") {
      return args.reduce(
        (acc, {
          functions,
          consts: argConsts
        }) => {
          const value2 = functions.map(parseProperty).join("");
          const valueWithZod = `${value2.startsWith(".") ? "zod" : ""}${value2}`;
          if (argConsts.length) {
            consts += argConsts.join("\n");
          }
          if (!acc) {
            acc += valueWithZod;
            return acc;
          }
          acc += `.and(${valueWithZod})`;
          return acc;
        },
        ""
      );
    }
    if (fn === "oneOf" || fn === "anyOf") {
      if (args.length === 1) {
        return args[0].functions.map(parseProperty).join("");
      }
      const union = args.map(
        ({ functions }) => {
          const value2 = functions.map(parseProperty).join("");
          const valueWithZod = `${value2.startsWith(".") ? "zod" : ""}${value2}`;
          return valueWithZod;
        }
      );
      return `.union([${union}])`;
    }
    if (fn === "additionalProperties") {
      const value2 = args.functions.map(parseProperty).join("");
      const valueWithZod = `${value2.startsWith(".") ? "zod" : ""}${value2}`;
      consts += args.consts;
      return `zod.record(zod.string(), ${valueWithZod})`;
    }
    if (fn === "object" || fn === "strictObject") {
      const objectType = getObjectFunctionName(isZodV4, strict);
      return `zod.${objectType}({
${Object.entries(args).map(([key, schema2]) => {
        const value2 = schema2.functions.map(parseProperty).join("");
        consts += schema2.consts.join("\n");
        return `  "${key}": ${value2.startsWith(".") ? "zod" : ""}${value2}`;
      }).join(",\n")}
})`;
    }
    if (fn === "array") {
      const value2 = args.functions.map(parseProperty).join("");
      if (typeof args.consts === "string") {
        consts += args.consts;
      } else if (Array.isArray(args.consts)) {
        consts += args.consts.join("\n");
      }
      return `.array(${value2.startsWith(".") ? "zod" : ""}${value2})`;
    }
    if (fn === "strict" && !isZodV4) {
      return ".strict()";
    }
    if (fn === "tuple") {
      return `zod.tuple([${args.map((x) => {
        const value2 = x.functions.map(parseProperty).join("");
        return `${value2.startsWith(".") ? "zod" : ""}${value2}`;
      }).join(",\n")}])`;
    }
    if (fn === "rest") {
      return `.rest(zod${args.functions.map(parseProperty)})`;
    }
    const shouldCoerceType = coerceTypes && (Array.isArray(coerceTypes) ? coerceTypes.includes(fn) : COERCIBLE_TYPES.includes(fn));
    if (fn !== "date" && shouldCoerceType || fn === "date" && shouldCoerceType && context.output.override.useDates) {
      return `.coerce.${fn}(${args})`;
    }
    return `.${fn}(${args})`;
  };
  consts += input.consts.join("\n");
  const schema = input.functions.map(parseProperty).join("");
  const value = preprocess ? `.preprocess(${preprocess.name}, ${schema.startsWith(".") ? "zod" : ""}${schema})` : schema;
  const zod = `${value.startsWith(".") ? "zod" : ""}${value}`;
  return { zod, consts };
};
var deferenceScalar = (value, context) => {
  if ((0, import_core2.isObject)(value)) {
    return deference(value, context);
  } else if (Array.isArray(value)) {
    return value.map((item) => deferenceScalar(item, context));
  } else {
    return value;
  }
};
var deference = (schema, context) => {
  var _a;
  const refName = "$ref" in schema ? schema.$ref : void 0;
  if (refName && ((_a = context.parents) == null ? void 0 : _a.includes(refName))) {
    return {};
  }
  const childContext = {
    ...context,
    ...refName ? { parents: [...context.parents || [], refName] } : void 0
  };
  const { schema: resolvedSchema } = (0, import_core2.resolveRef)(
    schema,
    childContext
  );
  const resolvedSpecKey = refName ? (0, import_core2.getRefInfo)(refName, context).specKey : void 0;
  const resolvedContext = {
    ...childContext,
    specKey: resolvedSpecKey != null ? resolvedSpecKey : childContext.specKey
  };
  return Object.entries(resolvedSchema).reduce((acc, [key, value]) => {
    if (key === "properties" && (0, import_core2.isObject)(value)) {
      acc[key] = Object.entries(value).reduce(
        (props, [propKey, propSchema]) => {
          props[propKey] = deference(
            propSchema,
            resolvedContext
          );
          return props;
        },
        {}
      );
    } else if (key === "default" || key === "example" || key === "examples") {
      acc[key] = value;
    } else {
      acc[key] = deferenceScalar(value, resolvedContext);
    }
    return acc;
  }, {});
};
var parseBodyAndResponse = ({
  data,
  context,
  name,
  strict,
  generate,
  isZodV4,
  parseType
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h;
  if (!data || !generate) {
    return {
      input: { functions: [], consts: [] },
      isArray: false
    };
  }
  const resolvedRef = (0, import_core2.resolveRef)(
    data,
    context
  ).schema;
  const schema = ((_b = (_a = resolvedRef.content) == null ? void 0 : _a["application/json"]) == null ? void 0 : _b.schema) || ((_d = (_c = resolvedRef.content) == null ? void 0 : _c["multipart/form-data"]) == null ? void 0 : _d.schema);
  if (!schema) {
    return {
      input: { functions: [], consts: [] },
      isArray: false
    };
  }
  const resolvedJsonSchema = deference(schema, context);
  if (resolvedJsonSchema.items) {
    const min = (_f = (_e = resolvedJsonSchema.minimum) != null ? _e : resolvedJsonSchema.minLength) != null ? _f : resolvedJsonSchema.minItems;
    const max = (_h = (_g = resolvedJsonSchema.maximum) != null ? _g : resolvedJsonSchema.maxLength) != null ? _h : resolvedJsonSchema.maxItems;
    return {
      input: generateZodValidationSchemaDefinition(
        parseType === "body" ? removeReadOnlyProperties(resolvedJsonSchema.items) : resolvedJsonSchema.items,
        context,
        name,
        strict,
        isZodV4,
        {
          required: true
        }
      ),
      isArray: true,
      rules: {
        ...typeof min !== "undefined" ? { min } : {},
        ...typeof max !== "undefined" ? { max } : {}
      }
    };
  }
  return {
    input: generateZodValidationSchemaDefinition(
      parseType === "body" ? removeReadOnlyProperties(resolvedJsonSchema) : resolvedJsonSchema,
      context,
      name,
      strict,
      isZodV4,
      {
        required: true
      }
    ),
    isArray: false
  };
};
var parseParameters = ({
  data,
  context,
  operationName,
  isZodV4,
  strict,
  generate
}) => {
  if (!data) {
    return {
      headers: {
        functions: [],
        consts: []
      },
      queryParams: {
        functions: [],
        consts: []
      },
      params: {
        functions: [],
        consts: []
      }
    };
  }
  const defintionsByParameters = data.reduce(
    (acc, val) => {
      var _a;
      const { schema: parameter } = (0, import_core2.resolveRef)(val, context);
      if (!parameter.schema) {
        return acc;
      }
      const schema = deference(parameter.schema, context);
      schema.description = parameter.description;
      const mapStrict = {
        path: strict.param,
        query: strict.query,
        header: strict.header
      };
      const mapGenerate = {
        path: generate.param,
        query: generate.query,
        header: generate.header
      };
      const definition = generateZodValidationSchemaDefinition(
        schema,
        context,
        (0, import_core2.camel)(`${operationName}-${parameter.in}-${parameter.name}`),
        (_a = mapStrict[parameter.in]) != null ? _a : false,
        isZodV4,
        {
          required: parameter.required
        }
      );
      if (parameter.in === "header" && mapGenerate.header) {
        return {
          ...acc,
          headers: { ...acc.headers, [parameter.name]: definition }
        };
      }
      if (parameter.in === "query" && mapGenerate.query) {
        return {
          ...acc,
          queryParams: { ...acc.queryParams, [parameter.name]: definition }
        };
      }
      if (parameter.in === "path" && mapGenerate.path) {
        return {
          ...acc,
          params: { ...acc.params, [parameter.name]: definition }
        };
      }
      return acc;
    },
    {
      headers: {},
      queryParams: {},
      params: {}
    }
  );
  const headers = {
    functions: [],
    consts: []
  };
  if (Object.keys(defintionsByParameters.headers).length) {
    const parameterFunctions = getParameterFunctions(
      isZodV4,
      strict.header,
      defintionsByParameters.headers
    );
    headers.functions.push(...parameterFunctions);
  }
  const queryParams = {
    functions: [],
    consts: []
  };
  if (Object.keys(defintionsByParameters.queryParams).length) {
    const parameterFunctions = getParameterFunctions(
      isZodV4,
      strict.query,
      defintionsByParameters.queryParams
    );
    queryParams.functions.push(...parameterFunctions);
  }
  const params = {
    functions: [],
    consts: []
  };
  if (Object.keys(defintionsByParameters.params).length) {
    const parameterFunctions = getParameterFunctions(
      isZodV4,
      strict.param,
      defintionsByParameters.params
    );
    params.functions.push(...parameterFunctions);
  }
  return {
    headers,
    queryParams,
    params
  };
};
var generateZodRoute = async ({ operationName, verb, override }, { pathRoute, context, output }) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  const isZodV4 = !!context.output.packageJson && isZodVersionV4(context.output.packageJson);
  const spec = context.specs[context.specKey].paths[pathRoute];
  const parameters = (_a = spec == null ? void 0 : spec[verb]) == null ? void 0 : _a.parameters;
  const parsedParameters = parseParameters({
    data: parameters,
    context,
    operationName,
    isZodV4,
    strict: override.zod.strict,
    generate: override.zod.generate
  });
  const requestBody = (_b = spec == null ? void 0 : spec[verb]) == null ? void 0 : _b.requestBody;
  const parsedBody = parseBodyAndResponse({
    data: requestBody,
    context,
    name: (0, import_core2.camel)(`${operationName}-body`),
    strict: override.zod.strict.body,
    generate: override.zod.generate.body,
    isZodV4,
    parseType: "body"
  });
  const responses = context.output.override.zod.generateEachHttpStatus ? Object.entries((_d = (_c = spec == null ? void 0 : spec[verb]) == null ? void 0 : _c.responses) != null ? _d : {}) : [["", (_e = spec == null ? void 0 : spec[verb]) == null ? void 0 : _e.responses[200]]];
  const parsedResponses = responses.map(
    ([code, response]) => parseBodyAndResponse({
      data: response,
      context,
      name: (0, import_core2.camel)(`${operationName}-${code}-response`),
      strict: override.zod.strict.response,
      generate: override.zod.generate.response,
      isZodV4,
      parseType: "response"
    })
  );
  const preprocessParams = ((_f = override.zod.preprocess) == null ? void 0 : _f.param) ? await (0, import_core2.generateMutator)({
    output,
    mutator: override.zod.preprocess.response,
    name: `${operationName}PreprocessParams`,
    workspace: context.workspace,
    tsconfig: context.output.tsconfig
  }) : void 0;
  const inputParams = parseZodValidationSchemaDefinition(
    parsedParameters.params,
    context,
    override.zod.coerce.param,
    override.zod.strict.param,
    isZodV4,
    preprocessParams
  );
  if (override.coerceTypes) {
    console.warn(
      "override.coerceTypes is deprecated, please use override.zod.coerce instead."
    );
  }
  const preprocessQueryParams = ((_g = override.zod.preprocess) == null ? void 0 : _g.query) ? await (0, import_core2.generateMutator)({
    output,
    mutator: override.zod.preprocess.response,
    name: `${operationName}PreprocessQueryParams`,
    workspace: context.workspace,
    tsconfig: context.output.tsconfig
  }) : void 0;
  const inputQueryParams = parseZodValidationSchemaDefinition(
    parsedParameters.queryParams,
    context,
    (_h = override.zod.coerce.query) != null ? _h : override.coerceTypes,
    override.zod.strict.query,
    isZodV4,
    preprocessQueryParams
  );
  const preprocessHeader = ((_i = override.zod.preprocess) == null ? void 0 : _i.header) ? await (0, import_core2.generateMutator)({
    output,
    mutator: override.zod.preprocess.response,
    name: `${operationName}PreprocessHeader`,
    workspace: context.workspace,
    tsconfig: context.output.tsconfig
  }) : void 0;
  const inputHeaders = parseZodValidationSchemaDefinition(
    parsedParameters.headers,
    context,
    override.zod.coerce.header,
    override.zod.strict.header,
    isZodV4,
    preprocessHeader
  );
  const preprocessBody = ((_j = override.zod.preprocess) == null ? void 0 : _j.body) ? await (0, import_core2.generateMutator)({
    output,
    mutator: override.zod.preprocess.response,
    name: `${operationName}PreprocessBody`,
    workspace: context.workspace,
    tsconfig: context.output.tsconfig
  }) : void 0;
  const inputBody = parseZodValidationSchemaDefinition(
    parsedBody.input,
    context,
    override.zod.coerce.body,
    override.zod.strict.body,
    isZodV4,
    preprocessBody
  );
  const preprocessResponse = ((_k = override.zod.preprocess) == null ? void 0 : _k.response) ? await (0, import_core2.generateMutator)({
    output,
    mutator: override.zod.preprocess.response,
    name: `${operationName}PreprocessResponse`,
    workspace: context.workspace,
    tsconfig: context.output.tsconfig
  }) : void 0;
  const inputResponses = parsedResponses.map(
    (parsedResponse) => parseZodValidationSchemaDefinition(
      parsedResponse.input,
      context,
      override.zod.coerce.response,
      override.zod.strict.response,
      isZodV4,
      preprocessResponse
    )
  );
  if (!inputParams.zod && !inputQueryParams.zod && !inputHeaders.zod && !inputBody.zod && !inputResponses.some((inputResponse) => inputResponse.zod)) {
    return {
      implemtation: "",
      mutators: []
    };
  }
  return {
    implementation: [
      ...inputParams.consts ? [inputParams.consts] : [],
      ...inputParams.zod ? [`export const ${operationName}Params = ${inputParams.zod}`] : [],
      ...inputQueryParams.consts ? [inputQueryParams.consts] : [],
      ...inputQueryParams.zod ? [`export const ${operationName}QueryParams = ${inputQueryParams.zod}`] : [],
      ...inputHeaders.consts ? [inputHeaders.consts] : [],
      ...inputHeaders.zod ? [`export const ${operationName}Header = ${inputHeaders.zod}`] : [],
      ...inputBody.consts ? [inputBody.consts] : [],
      ...inputBody.zod ? [
        parsedBody.isArray ? `export const ${operationName}BodyItem = ${inputBody.zod}
export const ${operationName}Body = zod.array(${operationName}BodyItem)${((_l = parsedBody.rules) == null ? void 0 : _l.min) ? `.min(${(_m = parsedBody.rules) == null ? void 0 : _m.min})` : ""}${((_n = parsedBody.rules) == null ? void 0 : _n.max) ? `.max(${(_o = parsedBody.rules) == null ? void 0 : _o.max})` : ""}` : `export const ${operationName}Body = ${inputBody.zod}`
      ] : [],
      ...inputResponses.map((inputResponse, index) => {
        var _a2, _b2, _c2, _d2;
        const operationResponse = (0, import_core2.camel)(
          `${operationName}-${responses[index][0]}-response`
        );
        return [
          ...inputResponse.consts ? [inputResponse.consts] : [],
          ...inputResponse.zod ? [
            parsedResponses[index].isArray ? `export const ${operationResponse}Item = ${inputResponse.zod}
export const ${operationResponse} = zod.array(${operationResponse}Item)${((_a2 = parsedResponses[index].rules) == null ? void 0 : _a2.min) ? `.min(${(_b2 = parsedResponses[index].rules) == null ? void 0 : _b2.min})` : ""}${((_c2 = parsedResponses[index].rules) == null ? void 0 : _c2.max) ? `.max(${(_d2 = parsedResponses[index].rules) == null ? void 0 : _d2.max})` : ""}` : `export const ${operationResponse} = ${inputResponse.zod}`
          ] : []
        ];
      }).flat()
    ].join("\n\n"),
    mutators: preprocessResponse ? [preprocessResponse] : []
  };
};
var generateZod = async (verbOptions, options) => {
  const { implementation, mutators } = await generateZodRoute(
    verbOptions,
    options
  );
  return {
    implementation: implementation ? `${implementation}

` : "",
    imports: [],
    mutators
  };
};
var zodClientBuilder = {
  client: generateZod,
  dependencies: getZodDependencies
};
var builder = () => () => zodClientBuilder;
var index_default = builder;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  generateZod,
  generateZodValidationSchemaDefinition,
  getZodDependencies,
  parseZodValidationSchemaDefinition
});
//# sourceMappingURL=index.js.map