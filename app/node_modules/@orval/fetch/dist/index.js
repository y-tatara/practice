"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  builder: () => builder,
  default: () => index_default,
  fetchResponseTypeName: () => fetchResponseTypeName,
  generateClient: () => generateClient,
  generateFetchHeader: () => generateFetchHeader,
  generateRequestFunction: () => generateRequestFunction
});
module.exports = __toCommonJS(index_exports);
var import_core = require("@orval/core");
var import_core2 = require("@orval/core");
var generateRequestFunction = ({
  queryParams,
  headers,
  operationName,
  response,
  mutator,
  body,
  props,
  verb,
  fetchReviver,
  formData,
  formUrlEncoded,
  override
}, { route, context, pathRoute }) => {
  var _a, _b, _c, _d;
  const isRequestOptions = (override == null ? void 0 : override.requestOptions) !== false;
  const isFormData = (override == null ? void 0 : override.formData.disabled) === false;
  const isFormUrlEncoded = (override == null ? void 0 : override.formUrlEncoded) !== false;
  const getUrlFnName = (0, import_core2.camel)(`get-${operationName}-url`);
  const getUrlFnProps = (0, import_core2.toObjectString)(
    props.filter(
      (prop) => prop.type === import_core2.GetterPropType.PARAM || prop.type === import_core2.GetterPropType.NAMED_PATH_PARAMS || prop.type === import_core2.GetterPropType.QUERY_PARAM
    ),
    "implementation"
  );
  const spec = context.specs[context.specKey].paths[pathRoute];
  const parameters = ((_a = spec == null ? void 0 : spec[verb]) == null ? void 0 : _a.parameters) || [];
  const explodeParameters = parameters.filter((parameter) => {
    const { schema } = (0, import_core2.resolveRef)(parameter, context);
    const schemaObject = schema.schema;
    return schema.in === "query" && schemaObject.type === "array" && (schema.explode || override.fetch.explode);
  });
  const explodeParametersNames = explodeParameters.map((parameter) => {
    const { schema } = (0, import_core2.resolveRef)(parameter, context);
    return schema.name;
  });
  const hasDateParams = context.output.override.useDates && parameters.some(
    (p) => "schema" in p && p.schema && "format" in p.schema && p.schema.format === "date-time"
  );
  const explodeArrayImplementation = explodeParameters.length > 0 ? `const explodeParameters = ${JSON.stringify(explodeParametersNames)};

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => normalizedParams.append(key, v === null ? 'null' : ${hasDateParams ? "v instanceof Date ? v.toISOString() : " : ""}v.toString()));
      return;
    }
      ` : "";
  const isExplodeParametersOnly = explodeParameters.length === parameters.length;
  const nomalParamsImplementation = `if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : ${hasDateParams ? "value instanceof Date ? value.toISOString() : " : ""}value.toString())
    }`;
  const getUrlFnImplementation = `export const ${getUrlFnName} = (${getUrlFnProps}) => {
${queryParams ? `  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    ${explodeArrayImplementation}
    ${!isExplodeParametersOnly ? nomalParamsImplementation : ""}
  });` : ""}

  ${queryParams ? `const stringifiedParams = normalizedParams.toString();` : ``}

  ${queryParams ? `return stringifiedParams.length > 0 ? \`${route}${"?${stringifiedParams}"}\` : \`${route}\`` : `return \`${route}\``}
}
`;
  const isContentTypeNdJson = (contentType) => contentType === "application/nd-json" || contentType === "application/x-ndjson";
  const isNdJson = response.contentTypes.some(isContentTypeNdJson);
  const responseTypeName = fetchResponseTypeName(
    (_b = override.fetch) == null ? void 0 : _b.includeHttpResponseReturnType,
    isNdJson ? "Response" : response.definition.success,
    operationName
  );
  const allResponses = [...response.types.success, ...response.types.errors];
  if (allResponses.length === 0) {
    allResponses.push({
      contentType: "",
      hasReadonlyProps: false,
      imports: [],
      isEnum: false,
      isRef: false,
      key: "default",
      schemas: [],
      type: "unknown",
      value: "unknown"
    });
  }
  const nonDefaultStatuses = allResponses.filter((r) => r.key !== "default").map((r) => r.key);
  const responseDataTypes = allResponses.map(
    (r) => allResponses.filter((r2) => r2.key === r.key).length > 1 ? { ...r, suffix: (0, import_core.pascal)(r.contentType) } : r
  ).map((r) => {
    const name = `${responseTypeName}${(0, import_core.pascal)(r.key)}${"suffix" in r ? r.suffix : ""}`;
    return {
      name,
      value: `export type ${name} = {
  ${isContentTypeNdJson(r.contentType) ? `stream: TypedResponse<${r.value}>` : `data: ${r.value || "unknown"}`}
  status: ${r.key === "default" ? nonDefaultStatuses.length ? `Exclude<HTTPStatusCodes, ${nonDefaultStatuses.join(" | ")}>` : "number" : r.key}
}`
    };
  });
  const compositeName = `${responseTypeName}Composite`;
  const compositeResponse = `${compositeName} = ${responseDataTypes.map((r) => r.name).join(" | ")}`;
  const responseTypeImplementation = override.fetch.includeHttpResponseReturnType ? `${responseDataTypes.map((r) => r.value).join("\n\n")}
    
export type ${compositeResponse};
    
export type ${responseTypeName} = ${compositeName} & {
  headers: Headers;
}

` : "";
  const getUrlFnProperties = props.filter(
    (prop) => prop.type === import_core2.GetterPropType.PARAM || prop.type === import_core2.GetterPropType.QUERY_PARAM || prop.type === import_core2.GetterPropType.NAMED_PATH_PARAMS
  ).map((param) => {
    if (param.type === import_core2.GetterPropType.NAMED_PATH_PARAMS) {
      return param.destructured;
    } else {
      return param.name;
    }
  }).join(",");
  const args = `${(0, import_core2.toObjectString)(props, "implementation")} ${isRequestOptions ? `options?: RequestInit` : ""}`;
  const returnType = `Promise<${responseTypeName}>`;
  const globalFetchOptions = (0, import_core2.isObject)(override == null ? void 0 : override.requestOptions) ? `${(_d = (_c = (0, import_core2.stringify)(override == null ? void 0 : override.requestOptions)) == null ? void 0 : _c.slice(1, -1)) == null ? void 0 : _d.trim()}` : "";
  const fetchMethodOption = `method: '${verb.toUpperCase()}'`;
  const ignoreContentTypes = ["multipart/form-data"];
  const headersToAdd = [
    ...body.contentType && !ignoreContentTypes.includes(body.contentType) ? [`'Content-Type': '${body.contentType}'`] : [],
    ...isNdJson && response.contentTypes.length === 1 ? [
      `Accept: ${response.contentTypes[0] === "application/x-ndjson" ? "'application/x-ndjson'" : "'application/nd-json'"}`
    ] : [],
    ...headers ? ["...headers"] : []
  ];
  const fetchHeadersOption = headersToAdd.length ? `headers: { ${headersToAdd.join(",")}, ...options?.headers }` : "";
  const requestBodyParams = (0, import_core2.generateBodyOptions)(
    body,
    isFormData,
    isFormUrlEncoded
  );
  const fetchBodyOption = requestBodyParams ? isFormData && body.formData || isFormUrlEncoded && body.formUrlEncoded || body.contentType === "text/plain" ? `body: ${requestBodyParams}` : `body: JSON.stringify(${requestBodyParams})` : "";
  const fetchFnOptions = `${getUrlFnName}(${getUrlFnProperties}),
  {${globalFetchOptions ? "\n" : ""}      ${globalFetchOptions}
    ${isRequestOptions ? "...options," : ""}
    ${fetchMethodOption}${fetchHeadersOption ? "," : ""}
    ${fetchHeadersOption}${fetchBodyOption ? "," : ""}
    ${fetchBodyOption}
  }
`;
  const reviver = fetchReviver ? `, ${fetchReviver.name}` : "";
  const fetchResponseImplementation = isNdJson ? `const stream = await fetch(${fetchFnOptions})

  ${override.fetch.includeHttpResponseReturnType ? `return { status: stream.status, stream, headers: stream.headers } as ${responseTypeName}` : `return stream`}
  ` : `const res = await fetch(${fetchFnOptions})

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: ${responseTypeName}${override.fetch.includeHttpResponseReturnType ? `['data']` : ""} = body ? JSON.parse(body${reviver}) : {}

  ${override.fetch.includeHttpResponseReturnType ? `return { data, status: res.status, headers: res.headers } as ${responseTypeName}` : "return data"}
`;
  const customFetchResponseImplementation = `return ${mutator == null ? void 0 : mutator.name}<${responseTypeName}>(${fetchFnOptions});`;
  const bodyForm = (0, import_core2.generateFormDataAndUrlEncodedFunction)({
    formData,
    formUrlEncoded,
    body,
    isFormData,
    isFormUrlEncoded
  });
  const fetchImplementationBody = mutator ? customFetchResponseImplementation : fetchResponseImplementation;
  const fetchImplementation = `export const ${operationName} = async (${args}): ${returnType} => {
  ${bodyForm ? `  ${bodyForm}` : ""}
  ${fetchImplementationBody}}
`;
  const implementation = `${responseTypeImplementation}${getUrlFnImplementation}
${fetchImplementation}
`;
  return implementation;
};
var fetchResponseTypeName = (includeHttpResponseReturnType, definitionSuccessResponse, operationName) => {
  return includeHttpResponseReturnType ? `${operationName}Response` : definitionSuccessResponse;
};
var generateClient = (verbOptions, options) => {
  const imports = (0, import_core2.generateVerbImports)(verbOptions);
  const functionImplementation = generateRequestFunction(verbOptions, options);
  return {
    implementation: `${functionImplementation}
`,
    imports
  };
};
var getHTTPStatusCodes = () => `
export type HTTPStatusCode1xx = 100 | 101 | 102 | 103;
export type HTTPStatusCode2xx = 200 | 201 | 202 | 203 | 204 | 205 | 206 | 207;
export type HTTPStatusCode3xx = 300 | 301 | 302 | 303 | 304 | 305 | 307 | 308;
export type HTTPStatusCode4xx = 400 | 401 | 402 | 403 | 404 | 405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 | 414 | 415 | 416 | 417 | 418 | 419 | 420 | 421 | 422 | 423 | 424 | 426 | 428 | 429 | 431 | 451;
export type HTTPStatusCode5xx = 500 | 501 | 502 | 503 | 504 | 505 | 507 | 511;
export type HTTPStatusCodes = HTTPStatusCode1xx | HTTPStatusCode2xx | HTTPStatusCode3xx | HTTPStatusCode4xx | HTTPStatusCode5xx;

`;
var generateFetchHeader = ({
  clientImplementation
}) => {
  return clientImplementation.includes("<HTTPStatusCodes,") ? getHTTPStatusCodes() : "";
};
var fetchClientBuilder = {
  client: generateClient,
  header: generateFetchHeader,
  dependencies: () => []
};
var builder = () => () => fetchClientBuilder;
var index_default = builder;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  fetchResponseTypeName,
  generateClient,
  generateFetchHeader,
  generateRequestFunction
});
//# sourceMappingURL=index.js.map