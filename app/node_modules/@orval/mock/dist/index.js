"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  DEFAULT_MOCK_OPTIONS: () => DEFAULT_MOCK_OPTIONS,
  generateMock: () => generateMock,
  generateMockImports: () => generateMockImports
});
module.exports = __toCommonJS(index_exports);

// src/msw/index.ts
var import_core8 = require("@orval/core");

// src/delay.ts
var getDelay = (override, options) => {
  var _a, _b, _c, _d;
  const overrideDelay = ((_a = override == null ? void 0 : override.mock) == null ? void 0 : _a.delay) !== void 0 ? (_b = override == null ? void 0 : override.mock) == null ? void 0 : _b.delay : options == null ? void 0 : options.delay;
  const delayFunctionLazyExecute = (_d = (_c = override == null ? void 0 : override.mock) == null ? void 0 : _c.delayFunctionLazyExecute) != null ? _d : options == null ? void 0 : options.delayFunctionLazyExecute;
  switch (typeof overrideDelay) {
    case "function":
      return delayFunctionLazyExecute ? overrideDelay : overrideDelay();
    case "number":
    case "boolean":
      return overrideDelay;
    default:
      return 1e3;
  }
};

// src/faker/getters/combine.ts
var import_core5 = require("@orval/core");

// src/faker/resolvers/value.ts
var import_core4 = require("@orval/core");

// src/faker/getters/scalar.ts
var import_core3 = require("@orval/core");

// src/faker/constants.ts
var DEFAULT_FORMAT_MOCK = {
  bic: "faker.finance.bic()",
  binary: "new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' ')))",
  city: "faker.location.city()",
  country: "faker.location.country()",
  date: "faker.date.past().toISOString().split('T')[0]",
  "date-time": "`${faker.date.past().toISOString().split('.')[0]}Z`",
  email: "faker.internet.email()",
  firstName: "faker.person.firstName()",
  gender: "faker.person.gender()",
  iban: "faker.finance.iban()",
  ipv4: "faker.internet.ipv4()",
  ipv6: "faker.internet.ipv6()",
  jobTitle: "faker.person.jobTitle()",
  lastName: "faker.person.lastName()",
  password: "faker.internet.password()",
  phoneNumber: "faker.phone.number()",
  streetName: "faker.location.street()",
  uri: "faker.internet.url()",
  url: "faker.internet.url()",
  userName: "faker.internet.userName()",
  uuid: "faker.string.uuid()",
  zipCode: "faker.location.zipCode()"
};
var DEFAULT_OBJECT_KEY_MOCK = "faker.string.alphanumeric(5)";

// src/faker/getters/object.ts
var import_core = require("@orval/core");
var overrideVarName = "overrideResponse";
var getMockObject = ({
  item,
  mockOptions,
  operationId,
  tags,
  combine,
  context,
  imports,
  existingReferencedProperties,
  splitMockImplementations,
  allowOverride = false
}) => {
  if ((0, import_core.isReference)(item)) {
    return resolveMockValue({
      schema: {
        ...item,
        name: item.name,
        path: item.path ? `${item.path}.${item.name}` : item.name
      },
      mockOptions,
      operationId,
      tags,
      context,
      imports,
      existingReferencedProperties,
      splitMockImplementations
    });
  }
  if (item.allOf || item.oneOf || item.anyOf) {
    const separator = item.allOf ? "allOf" : item.oneOf ? "oneOf" : "anyOf";
    return combineSchemasMock({
      item,
      separator,
      mockOptions,
      operationId,
      tags,
      combine,
      context,
      imports,
      existingReferencedProperties,
      splitMockImplementations
    });
  }
  if (Array.isArray(item.type)) {
    return combineSchemasMock({
      item: {
        anyOf: item.type.map((type) => ({ type })),
        name: item.name
      },
      separator: "anyOf",
      mockOptions,
      operationId,
      tags,
      combine,
      context,
      imports,
      existingReferencedProperties,
      splitMockImplementations
    });
  }
  if (item.properties) {
    let value = !combine || (combine == null ? void 0 : combine.separator) === "oneOf" || (combine == null ? void 0 : combine.separator) === "anyOf" ? "{" : "";
    const imports2 = [];
    const includedProperties = [];
    const entries = Object.entries(item.properties);
    if (context.output.propertySortOrder === import_core.PropertySortOrder.ALPHABETICAL) {
      entries.sort((a, b) => {
        return a[0].localeCompare(b[0]);
      });
    }
    const properyScalars = entries.map(([key, prop]) => {
      if (combine == null ? void 0 : combine.includedProperties.includes(key)) {
        return void 0;
      }
      const isRequired = (mockOptions == null ? void 0 : mockOptions.required) || (Array.isArray(item.required) ? item.required : []).includes(key);
      if ("$ref" in prop && existingReferencedProperties.includes(
        (0, import_core.pascal)(prop.$ref.split("/").pop())
      )) {
        return void 0;
      }
      const resolvedValue = resolveMockValue({
        schema: {
          ...prop,
          name: key,
          path: item.path ? `${item.path}.${key}` : `#.${key}`
        },
        mockOptions,
        operationId,
        tags,
        context,
        imports: imports2,
        existingReferencedProperties,
        splitMockImplementations
      });
      imports2.push(...resolvedValue.imports);
      includedProperties.push(key);
      const keyDefinition = (0, import_core.getKey)(key);
      if (!isRequired && !resolvedValue.overrided) {
        return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, undefined])`;
      }
      return `${keyDefinition}: ${resolvedValue.value}`;
    }).filter(Boolean);
    if (allowOverride) {
      properyScalars.push(`...${overrideVarName}`);
    }
    value += properyScalars.join(", ");
    value += !combine || (combine == null ? void 0 : combine.separator) === "oneOf" || (combine == null ? void 0 : combine.separator) === "anyOf" ? "}" : "";
    return {
      value,
      imports: imports2,
      name: item.name,
      includedProperties
    };
  }
  if (item.additionalProperties) {
    if ((0, import_core.isBoolean)(item.additionalProperties)) {
      return { value: `{}`, imports: [], name: item.name };
    }
    if ((0, import_core.isReference)(item.additionalProperties) && existingReferencedProperties.includes(
      item.additionalProperties.$ref.split("/").pop()
    )) {
      return { value: `{}`, imports: [], name: item.name };
    }
    const resolvedValue = resolveMockValue({
      schema: {
        ...item.additionalProperties,
        name: item.name,
        path: item.path ? `${item.path}.#` : "#"
      },
      mockOptions,
      operationId,
      tags,
      context,
      imports,
      existingReferencedProperties,
      splitMockImplementations
    });
    return {
      ...resolvedValue,
      value: `{
        [${DEFAULT_OBJECT_KEY_MOCK}]: ${resolvedValue.value}
      }`
    };
  }
  return { value: "{}", imports: [], name: item.name };
};

// src/faker/compatibleV9.ts
var import_core2 = require("@orval/core");
var getFakerPackageVersion = (packageJson) => {
  var _a, _b, _c, _d, _e;
  return (_e = (_c = (_a = packageJson.dependencies) == null ? void 0 : _a["@faker-js/faker"]) != null ? _c : (_b = packageJson.devDependencies) == null ? void 0 : _b["@faker-js/faker"]) != null ? _e : (_d = packageJson.peerDependencies) == null ? void 0 : _d["@faker-js/faker"];
};
var isFakerVersionV9 = (packageJson) => {
  const version = getFakerPackageVersion(packageJson);
  if (!version) {
    return false;
  }
  const withoutRc = version.split("-")[0];
  return (0, import_core2.compareVersions)(withoutRc, "9.0.0");
};

// src/faker/getters/scalar.ts
var getMockScalar = ({
  item,
  imports,
  mockOptions,
  operationId,
  tags,
  combine,
  context,
  existingReferencedProperties,
  splitMockImplementations,
  allowOverride = false
}) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  if (item.isRef) {
    existingReferencedProperties = [...existingReferencedProperties, item.name];
  }
  const operationProperty = resolveMockOverride(
    (_b = (_a = mockOptions == null ? void 0 : mockOptions.operations) == null ? void 0 : _a[operationId]) == null ? void 0 : _b.properties,
    item
  );
  if (operationProperty) {
    return operationProperty;
  }
  const overrideTag = Object.entries((_c = mockOptions == null ? void 0 : mockOptions.tags) != null ? _c : {}).sort((a, b) => {
    return a[0].localeCompare(b[0]);
  }).reduce(
    (acc, [tag, options]) => tags.includes(tag) ? (0, import_core3.mergeDeep)(acc, options) : acc,
    {}
  );
  const tagProperty = resolveMockOverride(overrideTag == null ? void 0 : overrideTag.properties, item);
  if (tagProperty) {
    return tagProperty;
  }
  const property = resolveMockOverride(mockOptions == null ? void 0 : mockOptions.properties, item);
  if (property) {
    return property;
  }
  if ((((_e = (_d = context.output.override) == null ? void 0 : _d.mock) == null ? void 0 : _e.useExamples) || (mockOptions == null ? void 0 : mockOptions.useExamples)) && item.example !== void 0) {
    return {
      value: JSON.stringify(item.example),
      imports: [],
      name: item.name,
      overrided: true
    };
  }
  const ALL_FORMAT = {
    ...DEFAULT_FORMAT_MOCK,
    ...(_f = mockOptions == null ? void 0 : mockOptions.format) != null ? _f : {}
  };
  if (item.format && ALL_FORMAT[item.format]) {
    let value = ALL_FORMAT[item.format];
    const dateFormats = ["date", "date-time"];
    if (dateFormats.includes(item.format) && context.output.override.useDates) {
      value = `new Date(${value})`;
    }
    return {
      value: getNullable(value, item.nullable),
      imports: [],
      name: item.name,
      overrided: false
    };
  }
  const type = getItemType(item);
  const isFakerV9 = !!context.output.packageJson && isFakerVersionV9(context.output.packageJson);
  switch (type) {
    case "number":
    case "integer": {
      const intFunction = item.format === "int64" && context.output.override.useBigInt ? "bigInt" : "int";
      let value = getNullable(
        `faker.number.${intFunction}({min: ${(_g = item.minimum) != null ? _g : mockOptions == null ? void 0 : mockOptions.numberMin}, max: ${(_h = item.maximum) != null ? _h : mockOptions == null ? void 0 : mockOptions.numberMax}${isFakerV9 ? `, multipleOf: ${item.multipleOf}` : ""}})`,
        item.nullable
      );
      if (type === "number") {
        value = getNullable(
          `faker.number.float({min: ${(_i = item.minimum) != null ? _i : mockOptions == null ? void 0 : mockOptions.numberMin}, max: ${(_j = item.maximum) != null ? _j : mockOptions == null ? void 0 : mockOptions.numberMax}, ${item.multipleOf ? `multipleOf: ${item.multipleOf}` : `fractionDigits: ${mockOptions == null ? void 0 : mockOptions.fractionDigits}`}})`,
          item.nullable
        );
      }
      const numberImports = [];
      if (item.enum) {
        value = getEnum(
          item,
          numberImports,
          context,
          existingReferencedProperties,
          "number"
        );
      } else if ("const" in item) {
        value = "" + item.const;
      }
      return {
        value,
        enums: item.enum,
        imports: numberImports,
        name: item.name
      };
    }
    case "boolean": {
      let value = "faker.datatype.boolean()";
      if ("const" in item) {
        value = "" + item.const;
      }
      return {
        value,
        imports: [],
        name: item.name
      };
    }
    case "array": {
      if (!item.items) {
        return { value: "[]", imports: [], name: item.name };
      }
      if ("$ref" in item.items && existingReferencedProperties.includes(
        (0, import_core3.pascal)(item.items.$ref.split("/").pop())
      )) {
        return { value: "[]", imports: [], name: item.name };
      }
      const {
        value,
        enums,
        imports: resolvedImports
      } = resolveMockValue({
        schema: {
          ...item.items,
          name: item.name,
          path: item.path ? `${item.path}.[]` : "#.[]"
        },
        combine,
        mockOptions,
        operationId,
        tags,
        context,
        imports,
        existingReferencedProperties,
        splitMockImplementations
      });
      if (enums) {
        return {
          value,
          imports: resolvedImports,
          name: item.name
        };
      }
      let mapValue = value;
      if (combine && !value.startsWith("faker") && !value.startsWith("{")) {
        mapValue = `{${value}}`;
      }
      return {
        value: `Array.from({ length: faker.number.int({ min: ${(_k = item.minItems) != null ? _k : mockOptions == null ? void 0 : mockOptions.arrayMin}, max: ${(_l = item.maxItems) != null ? _l : mockOptions == null ? void 0 : mockOptions.arrayMax} }) }, (_, i) => i + 1).map(() => (${mapValue}))`,
        imports: resolvedImports,
        name: item.name
      };
    }
    case "string": {
      const length = `{length: {min: ${(_m = item.minLength) != null ? _m : mockOptions == null ? void 0 : mockOptions.stringMin}, max: ${(_n = item.maxLength) != null ? _n : mockOptions == null ? void 0 : mockOptions.stringMax}}}`;
      let value = `faker.string.alpha(${length})`;
      const stringImports = [];
      if (item.enum) {
        value = getEnum(
          item,
          stringImports,
          context,
          existingReferencedProperties,
          "string"
        );
      } else if (item.pattern) {
        value = `faker.helpers.fromRegExp('${item.pattern}')`;
      } else if ("const" in item) {
        value = `'${item.const}'`;
      }
      return {
        value: getNullable(value, item.nullable),
        enums: item.enum,
        name: item.name,
        imports: stringImports
      };
    }
    case "null":
      return {
        value: "null",
        imports: [],
        name: item.name
      };
    default: {
      if (item.enum) {
        const enumImports = [];
        const value = getEnum(
          item,
          enumImports,
          context,
          existingReferencedProperties,
          void 0
        );
        return {
          value,
          enums: item.enum,
          imports: enumImports,
          name: item.name
        };
      }
      return getMockObject({
        item,
        mockOptions,
        operationId,
        tags,
        combine: combine ? {
          separator: combine.separator,
          includedProperties: []
        } : void 0,
        context,
        imports,
        existingReferencedProperties,
        splitMockImplementations,
        allowOverride
      });
    }
  }
};
function getItemType(item) {
  if (item.type) return item.type;
  if (!item.enum) return;
  const uniqTypes = new Set(item.enum.map((value) => typeof value));
  if (uniqTypes.size > 1) return;
  const type = Array.from(uniqTypes.values()).at(0);
  if (!type) return;
  return ["string", "number"].includes(type) ? type : void 0;
}
var getEnum = (item, imports, context, existingReferencedProperties, type) => {
  var _a, _b;
  if (!item.enum) return "";
  const joindEnumValues = item.enum.filter((e) => e !== null).map(
    (e) => type === "string" || type === void 0 && typeof e === "string" ? `'${(0, import_core3.escape)(e)}'` : e
  ).join(",");
  let enumValue = `[${joindEnumValues}]`;
  if (context.output.override.enumGenerationType === import_core3.EnumGeneration.ENUM) {
    if (item.isRef || existingReferencedProperties.length === 0) {
      enumValue += ` as ${item.name}${item.name.endsWith("[]") ? "" : "[]"}`;
      imports.push({
        name: item.name,
        ...!(0, import_core3.isRootKey)(context.specKey, context.target) ? { specKey: context.specKey } : {}
      });
    } else {
      enumValue += ` as ${existingReferencedProperties[existingReferencedProperties.length - 1]}['${item.name}']`;
      if (!((_a = item.path) == null ? void 0 : _a.endsWith("[]"))) enumValue += "[]";
      imports.push({
        name: existingReferencedProperties[existingReferencedProperties.length - 1],
        ...!(0, import_core3.isRootKey)(context.specKey, context.target) ? { specKey: context.specKey } : {}
      });
    }
  } else {
    enumValue += " as const";
  }
  if (item.isRef && type === "string") {
    enumValue = `Object.values(${item.name})`;
    imports.push({
      name: item.name,
      values: true,
      ...!(0, import_core3.isRootKey)(context.specKey, context.target) ? { specKey: context.specKey } : {}
    });
  }
  return ((_b = item.path) == null ? void 0 : _b.endsWith("[]")) ? `faker.helpers.arrayElements(${enumValue})` : `faker.helpers.arrayElement(${enumValue})`;
};

// src/faker/resolvers/value.ts
var isRegex = (key) => key[0] === "/" && key[key.length - 1] === "/";
var resolveMockOverride = (properties = {}, item) => {
  const path = item.path ? item.path : `#.${item.name}`;
  const property = Object.entries(properties).find(([key]) => {
    if (isRegex(key)) {
      const regex = new RegExp(key.slice(1, key.length - 1));
      if (regex.test(item.name) || regex.test(path)) {
        return true;
      }
    }
    if (`#.${key}` === path) {
      return true;
    }
    return false;
  });
  if (!property) {
    return;
  }
  return {
    value: getNullable(property[1], item.nullable),
    imports: [],
    name: item.name,
    overrided: true
  };
};
var getNullable = (value, nullable) => nullable ? `faker.helpers.arrayElement([${value}, null])` : value;
var resolveMockValue = ({
  schema,
  mockOptions,
  operationId,
  tags,
  combine,
  context,
  imports,
  existingReferencedProperties,
  splitMockImplementations,
  allowOverride
}) => {
  var _a, _b, _c;
  if ((0, import_core4.isReference)(schema)) {
    const {
      originalName,
      specKey = context.specKey,
      refPaths
    } = (0, import_core4.getRefInfo)(schema.$ref, context);
    const schemaRef = Array.isArray(refPaths) ? refPaths.reduce(
      (obj, key) => obj && typeof obj === "object" ? obj[key] : void 0,
      context.specs[specKey]
    ) : void 0;
    const newSchema = {
      ...schemaRef,
      name: (0, import_core4.pascal)(originalName),
      path: schema.path,
      isRef: true,
      required: [...(_a = schemaRef == null ? void 0 : schemaRef.required) != null ? _a : [], ...(_b = schema == null ? void 0 : schema.required) != null ? _b : []]
    };
    const newSeparator = newSchema.allOf ? "allOf" : newSchema.oneOf ? "oneOf" : "anyOf";
    const scalar2 = getMockScalar({
      item: newSchema,
      mockOptions,
      operationId,
      tags,
      combine: combine ? {
        separator: combine.separator === "anyOf" ? newSeparator : combine.separator,
        includedProperties: newSeparator === "allOf" ? [] : combine.includedProperties
      } : void 0,
      context: {
        ...context,
        specKey
      },
      imports,
      existingReferencedProperties,
      splitMockImplementations,
      allowOverride
    });
    if (scalar2.value && (newSchema.type === "object" || newSchema.allOf) && (combine == null ? void 0 : combine.separator) === "oneOf") {
      const funcName = `get${(0, import_core4.pascal)(operationId)}Response${(0, import_core4.pascal)(newSchema.name)}Mock`;
      if (!(splitMockImplementations == null ? void 0 : splitMockImplementations.some(
        (f) => f.includes(`export const ${funcName}`)
      ))) {
        const discriminatedProperty = (_c = newSchema.discriminator) == null ? void 0 : _c.propertyName;
        let type = `Partial<${newSchema.name}>`;
        if (discriminatedProperty) {
          type = `Omit<${type}, '${discriminatedProperty}'>`;
        }
        const args = `${overrideVarName}: ${type} = {}`;
        const func = `export const ${funcName} = (${args}): ${newSchema.name} => ({${scalar2.value.startsWith("...") ? "" : "..."}${scalar2.value}, ...${overrideVarName}});`;
        splitMockImplementations == null ? void 0 : splitMockImplementations.push(func);
      }
      if (newSchema.nullable) {
        scalar2.value = `${funcName}()`;
      } else {
        scalar2.value = `{...${funcName}()}`;
      }
      scalar2.imports.push({
        name: newSchema.name,
        specKey: (0, import_core4.isRootKey)(specKey, context.target) ? void 0 : specKey
      });
    }
    return {
      ...scalar2,
      type: getType(newSchema)
    };
  }
  const scalar = getMockScalar({
    item: schema,
    mockOptions,
    operationId,
    tags,
    combine,
    context,
    imports,
    existingReferencedProperties,
    splitMockImplementations,
    allowOverride
  });
  return {
    ...scalar,
    type: getType(schema)
  };
};
var getType = (schema) => {
  var _a;
  return (_a = schema.type) != null ? _a : schema.properties ? "object" : schema.items ? "array" : void 0;
};

// src/faker/getters/combine.ts
var combineSchemasMock = ({
  item,
  separator,
  mockOptions,
  operationId,
  tags,
  combine,
  context,
  imports,
  existingReferencedProperties,
  splitMockImplementations
}) => {
  var _a, _b, _c, _d;
  const combineImports = [];
  const includedProperties = ((_a = combine == null ? void 0 : combine.includedProperties) != null ? _a : []).slice(0);
  const isRefAndNotExisting = (0, import_core5.isReference)(item) && !existingReferencedProperties.includes(item.name);
  const itemResolvedValue = isRefAndNotExisting || item.properties ? resolveMockValue({
    schema: Object.fromEntries(
      Object.entries(item).filter(([key]) => key !== separator)
    ),
    combine: {
      separator: "allOf",
      includedProperties: []
    },
    mockOptions,
    operationId,
    tags,
    context,
    imports,
    existingReferencedProperties,
    splitMockImplementations
  }) : void 0;
  includedProperties.push(...(_b = itemResolvedValue == null ? void 0 : itemResolvedValue.includedProperties) != null ? _b : []);
  combineImports.push(...(_c = itemResolvedValue == null ? void 0 : itemResolvedValue.imports) != null ? _c : []);
  let containsOnlyPrimitiveValues = true;
  const value = ((_d = item[separator]) != null ? _d : []).reduce(
    (acc, val, _, arr) => {
      var _a2, _b2;
      if ("$ref" in val && existingReferencedProperties.includes(
        (0, import_core5.pascal)(val.$ref.split("/").pop())
      )) {
        if (arr.length === 1) {
          return "undefined";
        }
        return acc;
      }
      if (separator === "allOf" && item.required) {
        if ((0, import_core5.isSchema)(val) && val.required) {
          val = { ...val, required: [...item.required, ...val.required] };
        } else {
          val = { ...val, required: item.required };
        }
      }
      const resolvedValue = resolveMockValue({
        schema: {
          ...val,
          name: item.name,
          path: item.path ? item.path : "#"
        },
        combine: {
          separator,
          includedProperties: separator !== "oneOf" ? includedProperties : (_a2 = itemResolvedValue == null ? void 0 : itemResolvedValue.includedProperties) != null ? _a2 : []
        },
        mockOptions,
        operationId,
        tags,
        context,
        imports,
        existingReferencedProperties,
        splitMockImplementations
      });
      combineImports.push(...resolvedValue.imports);
      includedProperties.push(...(_b2 = resolvedValue.includedProperties) != null ? _b2 : []);
      if (resolvedValue.value === "{}") {
        containsOnlyPrimitiveValues = false;
        return acc;
      }
      if (separator === "allOf") {
        if (resolvedValue.value.startsWith("{") || !resolvedValue.type) {
          containsOnlyPrimitiveValues = false;
          return `${acc}...${resolvedValue.value},`;
        } else if (resolvedValue.type === "object") {
          containsOnlyPrimitiveValues = false;
          if (resolvedValue.value.startsWith("faker")) {
            return `${acc}...${resolvedValue.value},`;
          } else {
            return `${acc}...{${resolvedValue.value}},`;
          }
        }
      }
      return `${acc}${resolvedValue.value},`;
    },
    `${separator === "allOf" ? "" : "faker.helpers.arrayElement(["}`
  );
  let finalValue = value === "undefined" ? value : `${separator === "allOf" && !containsOnlyPrimitiveValues ? "{" : ""}${value}${separator === "allOf" ? containsOnlyPrimitiveValues ? "" : "}" : "])"}`;
  if (itemResolvedValue) {
    if (finalValue.startsWith("...")) {
      finalValue = `...{${finalValue}, ${itemResolvedValue.value}}`;
    } else {
      finalValue = `{...${finalValue}, ${itemResolvedValue.value}}`;
    }
  }
  if (finalValue.endsWith(",")) {
    finalValue = finalValue.substring(0, finalValue.length - 1);
  }
  return {
    value: finalValue,
    imports: combineImports,
    name: item.name,
    includedProperties
  };
};

// src/faker/getters/route.ts
var import_core6 = require("@orval/core");
var hasParam = (path) => /[^{]*{[\w*_-]*}.*/.test(path);
var getRoutePath = (path) => {
  const matches = path.match(/([^{]*){?([\w*_-]*)}?(.*)/);
  if (!(matches == null ? void 0 : matches.length)) return path;
  const prev = matches[1];
  const param = (0, import_core6.sanitize)((0, import_core6.camel)(matches[2]), {
    es5keyword: true,
    underscore: true,
    dash: true,
    dot: true
  });
  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];
  if (hasParam(path)) {
    return `${prev}:${param}${next}`;
  } else {
    return `${prev}${param}${next}`;
  }
};
var getRouteMSW = (route, baseUrl = "*") => {
  const splittedRoute = route.split("/");
  return splittedRoute.reduce((acc, path, i) => {
    if (!path && !i) {
      return acc;
    }
    if (!path.includes("{")) {
      return `${acc}/${path}`;
    }
    return `${acc}/${getRoutePath(path)}`;
  }, baseUrl);
};

// src/msw/mocks.ts
var import_core7 = require("@orval/core");
var getMockPropertiesWithoutFunc = (properties, spec) => Object.entries((0, import_core7.isFunction)(properties) ? properties(spec) : properties).reduce((acc, [key, value]) => {
  const implementation = (0, import_core7.isFunction)(value) ? `(${value})()` : (0, import_core7.stringify)(value);
  acc[key] = implementation == null ? void 0 : implementation.replace(
    /import_faker.defaults|import_faker.faker/g,
    "faker"
  );
  return acc;
}, {});
var getMockWithoutFunc = (spec, override) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  return {
    arrayMin: (_a = override == null ? void 0 : override.mock) == null ? void 0 : _a.arrayMin,
    arrayMax: (_b = override == null ? void 0 : override.mock) == null ? void 0 : _b.arrayMax,
    stringMin: (_c = override == null ? void 0 : override.mock) == null ? void 0 : _c.stringMin,
    stringMax: (_d = override == null ? void 0 : override.mock) == null ? void 0 : _d.stringMax,
    numberMin: (_e = override == null ? void 0 : override.mock) == null ? void 0 : _e.numberMin,
    numberMax: (_f = override == null ? void 0 : override.mock) == null ? void 0 : _f.numberMax,
    required: (_g = override == null ? void 0 : override.mock) == null ? void 0 : _g.required,
    fractionDigits: (_h = override == null ? void 0 : override.mock) == null ? void 0 : _h.fractionDigits,
    ...((_i = override == null ? void 0 : override.mock) == null ? void 0 : _i.properties) ? {
      properties: getMockPropertiesWithoutFunc(
        override.mock.properties,
        spec
      )
    } : {},
    ...((_j = override == null ? void 0 : override.mock) == null ? void 0 : _j.format) ? {
      format: getMockPropertiesWithoutFunc(override.mock.format, spec)
    } : {},
    ...(override == null ? void 0 : override.operations) ? {
      operations: Object.entries(override.operations).reduce((acc, [key, value]) => {
        var _a2;
        if ((_a2 = value.mock) == null ? void 0 : _a2.properties) {
          acc[key] = {
            properties: getMockPropertiesWithoutFunc(
              value.mock.properties,
              spec
            )
          };
        }
        return acc;
      }, {})
    } : {},
    ...(override == null ? void 0 : override.tags) ? {
      tags: Object.entries(override.tags).reduce((acc, [key, value]) => {
        var _a2;
        if ((_a2 = value.mock) == null ? void 0 : _a2.properties) {
          acc[key] = {
            properties: getMockPropertiesWithoutFunc(
              value.mock.properties,
              spec
            )
          };
        }
        return acc;
      }, {})
    } : {}
  };
};
var getMockScalarJsTypes = (definition, mockOptionsWithoutFunc) => {
  const isArray = definition.endsWith("[]");
  const type = isArray ? definition.slice(0, -2) : definition;
  switch (type) {
    case "number":
      return isArray ? `Array.from({length: faker.number.int({min: ${mockOptionsWithoutFunc.arrayMin}, max: ${mockOptionsWithoutFunc.arrayMax}})}, () => faker.number.int())` : "faker.number.int()";
    case "string":
      return isArray ? `Array.from({length: faker.number.int({min: ${mockOptionsWithoutFunc == null ? void 0 : mockOptionsWithoutFunc.arrayMin},max: ${mockOptionsWithoutFunc == null ? void 0 : mockOptionsWithoutFunc.arrayMax}})}, () => faker.word.sample())` : "faker.word.sample()";
    default:
      return "undefined";
  }
};
var getResponsesMockDefinition = ({
  operationId,
  tags,
  returnType,
  responses,
  imports: responseImports,
  mockOptionsWithoutFunc,
  transformer,
  context,
  mockOptions,
  splitMockImplementations
}) => {
  return responses.reduce(
    (acc, { value: definition, originalSchema, example, examples, imports, isRef }) => {
      var _a, _b, _c, _d, _e, _f;
      if (((_b = (_a = context.output.override) == null ? void 0 : _a.mock) == null ? void 0 : _b.useExamples) || (mockOptions == null ? void 0 : mockOptions.useExamples)) {
        let exampleValue = example || (originalSchema == null ? void 0 : originalSchema.example) || Object.values(examples || {})[0] || ((_c = originalSchema == null ? void 0 : originalSchema.examples) == null ? void 0 : _c[0]);
        exampleValue = (_d = exampleValue == null ? void 0 : exampleValue.value) != null ? _d : exampleValue;
        if (exampleValue) {
          acc.definitions.push(
            transformer ? transformer(exampleValue, returnType) : JSON.stringify(exampleValue)
          );
          return acc;
        }
      }
      if (!definition || import_core7.generalJSTypesWithArray.includes(definition)) {
        const value = getMockScalarJsTypes(definition, mockOptionsWithoutFunc);
        acc.definitions.push(
          transformer ? transformer(value, returnType) : value
        );
        return acc;
      }
      if (!originalSchema) {
        return acc;
      }
      const resolvedRef = (0, import_core7.resolveRef)(originalSchema, context);
      const scalar = getMockScalar({
        item: {
          name: definition,
          ...resolvedRef.schema
        },
        imports,
        mockOptions: mockOptionsWithoutFunc,
        operationId,
        tags,
        context: isRef ? {
          ...context,
          specKey: (_f = (_e = responseImports[0]) == null ? void 0 : _e.specKey) != null ? _f : context.specKey
        } : context,
        existingReferencedProperties: [],
        splitMockImplementations,
        allowOverride: true
      });
      acc.imports.push(...scalar.imports);
      acc.definitions.push(
        transformer ? transformer(scalar.value, returnType) : scalar.value.toString()
      );
      return acc;
    },
    {
      definitions: [],
      imports: []
    }
  );
};
var getMockDefinition = ({
  operationId,
  tags,
  returnType,
  responses,
  imports: responseImports,
  override,
  transformer,
  context,
  mockOptions,
  splitMockImplementations
}) => {
  const mockOptionsWithoutFunc = getMockWithoutFunc(
    context.specs[context.specKey],
    override
  );
  const { definitions, imports } = getResponsesMockDefinition({
    operationId,
    tags,
    returnType,
    responses,
    imports: responseImports,
    mockOptionsWithoutFunc,
    transformer,
    context,
    mockOptions,
    splitMockImplementations
  });
  return {
    definition: "[" + definitions.join(", ") + "]",
    definitions,
    imports
  };
};
var getMockOptionsDataOverride = (operationTags, operationId, override) => {
  var _a, _b, _c;
  const responseOverride = ((_c = (_b = (_a = override == null ? void 0 : override.operations) == null ? void 0 : _a[operationId]) == null ? void 0 : _b.mock) == null ? void 0 : _c.data) || operationTags.map((operationTag) => {
    var _a2, _b2, _c2;
    return (_c2 = (_b2 = (_a2 = override == null ? void 0 : override.tags) == null ? void 0 : _a2[operationTag]) == null ? void 0 : _b2.mock) == null ? void 0 : _c2.data;
  }).find((e) => e !== void 0);
  const implementation = (0, import_core7.isFunction)(responseOverride) ? `(${responseOverride})()` : (0, import_core7.stringify)(responseOverride);
  return implementation == null ? void 0 : implementation.replace(
    /import_faker.defaults|import_faker.faker/g,
    "faker"
  );
};

// src/msw/index.ts
var getMSWDependencies = (options) => {
  const hasDelay = (options == null ? void 0 : options.delay) !== false;
  const locale = options == null ? void 0 : options.locale;
  const exports2 = [
    { name: "http", values: true },
    { name: "HttpResponse", values: true }
  ];
  if (hasDelay) {
    exports2.push({ name: "delay", values: true });
  }
  return [
    {
      exports: exports2,
      dependency: "msw"
    },
    {
      exports: [{ name: "faker", values: true }],
      dependency: locale ? `@faker-js/faker/locale/${locale}` : "@faker-js/faker"
    }
  ];
};
var generateMSWImports = ({
  implementation,
  imports,
  specsName,
  hasSchemaDir,
  isAllowSyntheticDefaultImports,
  options
}) => {
  return (0, import_core8.generateDependencyImports)(
    implementation,
    [...getMSWDependencies(options), ...imports],
    specsName,
    hasSchemaDir,
    isAllowSyntheticDefaultImports
  );
};
var generateDefinition = (name, route, getResponseMockFunctionNameBase, handlerNameBase, { operationId, response, verb, tags }, { override, context, mock }, returnType, status, responseImports, responses, contentTypes, splitMockImplementations) => {
  const oldSplitMockImplementations = [...splitMockImplementations];
  const { definitions, definition, imports } = getMockDefinition({
    operationId,
    tags,
    returnType,
    responses,
    imports: responseImports,
    override,
    context,
    mockOptions: !(0, import_core8.isFunction)(mock) ? mock : void 0,
    splitMockImplementations
  });
  const mockData = getMockOptionsDataOverride(tags, operationId, override);
  let value = "";
  if (mockData) {
    value = mockData;
  } else if (definitions.length > 1) {
    value = `faker.helpers.arrayElement(${definition})`;
  } else if (definitions[0]) {
    value = definitions[0];
  }
  const isResponseOverridable = value.includes(overrideVarName);
  const isTextPlain = contentTypes.includes("text/plain");
  const isReturnHttpResponse = value && value !== "undefined";
  const getResponseMockFunctionName = `${getResponseMockFunctionNameBase}${(0, import_core8.pascal)(
    name
  )}`;
  const handlerName = `${handlerNameBase}${(0, import_core8.pascal)(name)}`;
  const addedSplitMockImplementations = splitMockImplementations.slice(
    oldSplitMockImplementations.length
  );
  splitMockImplementations.push(...addedSplitMockImplementations);
  const mockImplementations = addedSplitMockImplementations.length ? `${addedSplitMockImplementations.join("\n\n")}

` : "";
  const mockImplementation = isReturnHttpResponse ? `${mockImplementations}export const ${getResponseMockFunctionName} = (${isResponseOverridable ? `overrideResponse: Partial< ${returnType} > = {}` : ""})${mockData ? "" : `: ${returnType}`} => (${value})

` : mockImplementations;
  const delay = getDelay(override, !(0, import_core8.isFunction)(mock) ? mock : void 0);
  const infoParam = "info";
  const overrideResponse = `overrideResponse !== undefined
    ? (typeof overrideResponse === "function" ? await overrideResponse(${infoParam}) : overrideResponse)
    : ${getResponseMockFunctionName}()`;
  const handlerImplementation = `
export const ${handlerName} = (overrideResponse?: ${returnType} | ((${infoParam}: Parameters<Parameters<typeof http.${verb}>[1]>[0]) => Promise<${returnType}> | ${returnType})) => {
  return http.${verb}('${route}', async (${infoParam}) => {${delay !== false ? `await delay(${(0, import_core8.isFunction)(delay) ? `(${delay})()` : delay});` : ""}
  ${isReturnHttpResponse ? "" : `if (typeof overrideResponse === 'function') {await overrideResponse(info); }`}
    return new HttpResponse(${isReturnHttpResponse ? isTextPlain ? overrideResponse : `JSON.stringify(${overrideResponse})` : null},
      { status: ${status === "default" ? 200 : status.replace(/XX$/, "00")},
        ${isReturnHttpResponse ? `headers: { 'Content-Type': ${isTextPlain ? "'text/plain'" : "'application/json'"} }` : ""}
      })
  })
}
`;
  const includeResponseImports = !isTextPlain ? [
    ...imports,
    ...response.imports.filter((r) => {
      const reg = new RegExp(`\\b${r.name}\\b`);
      return reg.test(handlerImplementation) || reg.test(mockImplementation);
    })
  ] : imports;
  return {
    implementation: {
      function: mockImplementation,
      handlerName,
      handler: handlerImplementation
    },
    imports: includeResponseImports
  };
};
var generateMSW = (generatorVerbOptions, generatorOptions) => {
  var _a, _b, _c, _d;
  const { pathRoute, override, mock } = generatorOptions;
  const { operationId, response } = generatorVerbOptions;
  const route = getRouteMSW(
    pathRoute,
    (_b = (_a = override == null ? void 0 : override.mock) == null ? void 0 : _a.baseUrl) != null ? _b : !(0, import_core8.isFunction)(mock) ? mock == null ? void 0 : mock.baseUrl : void 0
  );
  const handlerName = `get${(0, import_core8.pascal)(operationId)}MockHandler`;
  const getResponseMockFunctionName = `get${(0, import_core8.pascal)(operationId)}ResponseMock`;
  const splitMockImplementations = [];
  const baseDefinition = generateDefinition(
    "",
    route,
    getResponseMockFunctionName,
    handlerName,
    generatorVerbOptions,
    generatorOptions,
    response.definition.success,
    (_d = (_c = response.types.success[0]) == null ? void 0 : _c.key) != null ? _d : "200",
    response.imports,
    response.types.success,
    response.contentTypes,
    splitMockImplementations
  );
  const mockImplementations = [baseDefinition.implementation.function];
  const handlerImplementations = [baseDefinition.implementation.handler];
  const imports = [...baseDefinition.imports];
  if (generatorOptions.mock && (0, import_core8.isObject)(generatorOptions.mock) && generatorOptions.mock.generateEachHttpStatus) {
    [...response.types.success, ...response.types.errors].forEach(
      (statusResponse) => {
        const definition = generateDefinition(
          statusResponse.key,
          route,
          getResponseMockFunctionName,
          handlerName,
          generatorVerbOptions,
          generatorOptions,
          statusResponse.value,
          statusResponse.key,
          response.imports,
          [statusResponse],
          [statusResponse.contentType],
          splitMockImplementations
        );
        mockImplementations.push(definition.implementation.function);
        handlerImplementations.push(definition.implementation.handler);
        imports.push(...definition.imports);
      }
    );
  }
  return {
    implementation: {
      function: mockImplementations.join("\n"),
      handlerName,
      handler: handlerImplementations.join("\n")
    },
    imports
  };
};

// src/index.ts
var DEFAULT_MOCK_OPTIONS = {
  type: "msw",
  useExamples: false
};
var generateMockImports = (importOptions) => {
  var _a;
  switch ((_a = importOptions.options) == null ? void 0 : _a.type) {
    default:
      return generateMSWImports(importOptions);
  }
};
var generateMock = (generatorVerbOptions, generatorOptions) => {
  switch (generatorOptions.mock.type) {
    default:
      return generateMSW(generatorVerbOptions, generatorOptions);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  DEFAULT_MOCK_OPTIONS,
  generateMock,
  generateMockImports
});
//# sourceMappingURL=index.js.map