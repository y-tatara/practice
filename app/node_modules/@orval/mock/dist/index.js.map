{"version":3,"sources":["../src/index.ts","../src/msw/index.ts","../src/delay.ts","../src/faker/getters/combine.ts","../src/faker/resolvers/value.ts","../src/faker/getters/scalar.ts","../src/faker/constants.ts","../src/faker/getters/object.ts","../src/faker/compatibleV9.ts","../src/faker/getters/route.ts","../src/msw/mocks.ts"],"sourcesContent":["import {\n  GenerateMockImports,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n} from '@orval/core';\nimport { generateMSW, generateMSWImports } from './msw';\n\nexport const DEFAULT_MOCK_OPTIONS: GlobalMockOptions = {\n  type: 'msw',\n  useExamples: false,\n};\n\nexport const generateMockImports: GenerateMockImports = (importOptions) => {\n  switch (importOptions.options?.type) {\n    default: // case 'msw':\n      return generateMSWImports(importOptions);\n  }\n};\n\nexport const generateMock = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: Omit<GeneratorOptions, 'mock'> & {\n    mock: GlobalMockOptions;\n  },\n) => {\n  switch (generatorOptions.mock.type) {\n    default: // case 'msw':\n      return generateMSW(generatorVerbOptions, generatorOptions);\n  }\n};\n","import {\n  ClientMockGeneratorBuilder,\n  generateDependencyImports,\n  GenerateMockImports,\n  GeneratorDependency,\n  GeneratorImport,\n  GeneratorOptions,\n  GeneratorVerbOptions,\n  GlobalMockOptions,\n  isFunction,\n  isObject,\n  pascal,\n  ResReqTypesValue,\n} from '@orval/core';\nimport { getDelay } from '../delay';\nimport { getRouteMSW, overrideVarName } from '../faker/getters';\nimport { getMockDefinition, getMockOptionsDataOverride } from './mocks';\n\nconst getMSWDependencies = (\n  options?: GlobalMockOptions,\n): GeneratorDependency[] => {\n  const hasDelay = options?.delay !== false;\n  const locale = options?.locale;\n\n  const exports = [\n    { name: 'http', values: true },\n    { name: 'HttpResponse', values: true },\n  ];\n\n  if (hasDelay) {\n    exports.push({ name: 'delay', values: true });\n  }\n\n  return [\n    {\n      exports,\n      dependency: 'msw',\n    },\n    {\n      exports: [{ name: 'faker', values: true }],\n      dependency: locale\n        ? `@faker-js/faker/locale/${locale}`\n        : '@faker-js/faker',\n    },\n  ];\n};\n\nexport const generateMSWImports: GenerateMockImports = ({\n  implementation,\n  imports,\n  specsName,\n  hasSchemaDir,\n  isAllowSyntheticDefaultImports,\n  options,\n}) => {\n  return generateDependencyImports(\n    implementation,\n    [...getMSWDependencies(options), ...imports],\n    specsName,\n    hasSchemaDir,\n    isAllowSyntheticDefaultImports,\n  );\n};\n\nconst generateDefinition = (\n  name: string,\n  route: string,\n  getResponseMockFunctionNameBase: string,\n  handlerNameBase: string,\n  { operationId, response, verb, tags }: GeneratorVerbOptions,\n  { override, context, mock }: GeneratorOptions,\n  returnType: string,\n  status: string,\n  responseImports: GeneratorImport[],\n  responses: ResReqTypesValue[],\n  contentTypes: string[],\n  splitMockImplementations: string[],\n) => {\n  const oldSplitMockImplementations = [...splitMockImplementations];\n  const { definitions, definition, imports } = getMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    override,\n    context,\n    mockOptions: !isFunction(mock) ? mock : undefined,\n    splitMockImplementations,\n  });\n\n  const mockData = getMockOptionsDataOverride(tags, operationId, override);\n\n  let value = '';\n\n  if (mockData) {\n    value = mockData;\n  } else if (definitions.length > 1) {\n    value = `faker.helpers.arrayElement(${definition})`;\n  } else if (definitions[0]) {\n    value = definitions[0];\n  }\n\n  const isResponseOverridable = value.includes(overrideVarName);\n  const isTextPlain = contentTypes.includes('text/plain');\n  const isReturnHttpResponse = value && value !== 'undefined';\n\n  const getResponseMockFunctionName = `${getResponseMockFunctionNameBase}${pascal(\n    name,\n  )}`;\n  const handlerName = `${handlerNameBase}${pascal(name)}`;\n\n  const addedSplitMockImplementations = splitMockImplementations.slice(\n    oldSplitMockImplementations.length,\n  );\n  splitMockImplementations.push(...addedSplitMockImplementations);\n  const mockImplementations = addedSplitMockImplementations.length\n    ? `${addedSplitMockImplementations.join('\\n\\n')}\\n\\n`\n    : '';\n\n  const mockImplementation = isReturnHttpResponse\n    ? `${mockImplementations}export const ${getResponseMockFunctionName} = (${\n        isResponseOverridable\n          ? `overrideResponse: Partial< ${returnType} > = {}`\n          : ''\n      })${mockData ? '' : `: ${returnType}`} => (${value})\\n\\n`\n    : mockImplementations;\n\n  const delay = getDelay(override, !isFunction(mock) ? mock : undefined);\n  const infoParam = 'info';\n  const overrideResponse = `overrideResponse !== undefined\n    ? (typeof overrideResponse === \"function\" ? await overrideResponse(${infoParam}) : overrideResponse)\n    : ${getResponseMockFunctionName}()`;\n  const handlerImplementation = `\nexport const ${handlerName} = (overrideResponse?: ${returnType} | ((${infoParam}: Parameters<Parameters<typeof http.${verb}>[1]>[0]) => Promise<${returnType}> | ${returnType})) => {\n  return http.${verb}('${route}', async (${infoParam}) => {${\n    delay !== false\n      ? `await delay(${isFunction(delay) ? `(${delay})()` : delay});`\n      : ''\n  }\n  ${isReturnHttpResponse ? '' : `if (typeof overrideResponse === 'function') {await overrideResponse(info); }`}\n    return new HttpResponse(${\n      isReturnHttpResponse\n        ? isTextPlain\n          ? overrideResponse\n          : `JSON.stringify(${overrideResponse})`\n        : null\n    },\n      { status: ${status === 'default' ? 200 : status.replace(/XX$/, '00')},\n        ${\n          isReturnHttpResponse\n            ? `headers: { 'Content-Type': ${isTextPlain ? \"'text/plain'\" : \"'application/json'\"} }`\n            : ''\n        }\n      })\n  })\n}\\n`;\n\n  const includeResponseImports = !isTextPlain\n    ? [\n        ...imports,\n        ...response.imports.filter((r) => {\n          // Only include imports which are actually used in mock.\n          const reg = new RegExp(`\\\\b${r.name}\\\\b`);\n          return (\n            reg.test(handlerImplementation) || reg.test(mockImplementation)\n          );\n        }),\n      ]\n    : imports;\n\n  return {\n    implementation: {\n      function: mockImplementation,\n      handlerName: handlerName,\n      handler: handlerImplementation,\n    },\n    imports: includeResponseImports,\n  };\n};\n\nexport const generateMSW = (\n  generatorVerbOptions: GeneratorVerbOptions,\n  generatorOptions: GeneratorOptions,\n): ClientMockGeneratorBuilder => {\n  const { pathRoute, override, mock } = generatorOptions;\n  const { operationId, response } = generatorVerbOptions;\n\n  const route = getRouteMSW(\n    pathRoute,\n    override?.mock?.baseUrl ?? (!isFunction(mock) ? mock?.baseUrl : undefined),\n  );\n\n  const handlerName = `get${pascal(operationId)}MockHandler`;\n  const getResponseMockFunctionName = `get${pascal(operationId)}ResponseMock`;\n\n  const splitMockImplementations: string[] = [];\n\n  const baseDefinition = generateDefinition(\n    '',\n    route,\n    getResponseMockFunctionName,\n    handlerName,\n    generatorVerbOptions,\n    generatorOptions,\n    response.definition.success,\n    response.types.success[0]?.key ?? '200',\n    response.imports,\n    response.types.success,\n    response.contentTypes,\n    splitMockImplementations,\n  );\n\n  const mockImplementations = [baseDefinition.implementation.function];\n  const handlerImplementations = [baseDefinition.implementation.handler];\n  const imports = [...baseDefinition.imports];\n\n  if (\n    generatorOptions.mock &&\n    isObject(generatorOptions.mock) &&\n    generatorOptions.mock.generateEachHttpStatus\n  ) {\n    [...response.types.success, ...response.types.errors].forEach(\n      (statusResponse) => {\n        const definition = generateDefinition(\n          statusResponse.key,\n          route,\n          getResponseMockFunctionName,\n          handlerName,\n          generatorVerbOptions,\n          generatorOptions,\n          statusResponse.value,\n          statusResponse.key,\n          response.imports,\n          [statusResponse],\n          [statusResponse.contentType],\n          splitMockImplementations,\n        );\n        mockImplementations.push(definition.implementation.function);\n        handlerImplementations.push(definition.implementation.handler);\n        imports.push(...definition.imports);\n      },\n    );\n  }\n\n  return {\n    implementation: {\n      function: mockImplementations.join('\\n'),\n      handlerName: handlerName,\n      handler: handlerImplementations.join('\\n'),\n    },\n    imports: imports,\n  };\n};\n","import { GlobalMockOptions, NormalizedOverrideOutput } from '@orval/core';\n\nexport const getDelay = (\n  override?: NormalizedOverrideOutput,\n  options?: GlobalMockOptions,\n): GlobalMockOptions['delay'] => {\n  const overrideDelay =\n    override?.mock?.delay !== undefined\n      ? override?.mock?.delay\n      : options?.delay;\n  const delayFunctionLazyExecute =\n    override?.mock?.delayFunctionLazyExecute ??\n    options?.delayFunctionLazyExecute;\n  switch (typeof overrideDelay) {\n    case 'function':\n      return delayFunctionLazyExecute ? overrideDelay : overrideDelay();\n    case 'number':\n    case 'boolean':\n      return overrideDelay;\n    default:\n      return 1000;\n  }\n};\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  isReference,\n  isSchema,\n  MockOptions,\n  pascal,\n} from '@orval/core';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { resolveMockValue } from '../resolvers';\n\nexport const combineSchemasMock = ({\n  item,\n  separator,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n}: {\n  item: MockSchemaObject;\n  separator: 'allOf' | 'oneOf' | 'anyOf';\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n}): MockDefinition => {\n  const combineImports: GeneratorImport[] = [];\n  const includedProperties: string[] = (\n    combine?.includedProperties ?? []\n  ).slice(0);\n\n  const isRefAndNotExisting =\n    isReference(item) && !existingReferencedProperties.includes(item.name);\n\n  const itemResolvedValue =\n    isRefAndNotExisting || item.properties\n      ? resolveMockValue({\n          schema: Object.fromEntries(\n            Object.entries(item).filter(([key]) => key !== separator),\n          ) as MockSchemaObject,\n          combine: {\n            separator: 'allOf',\n            includedProperties: [],\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        })\n      : undefined;\n\n  includedProperties.push(...(itemResolvedValue?.includedProperties ?? []));\n  combineImports.push(...(itemResolvedValue?.imports ?? []));\n  let containsOnlyPrimitiveValues = true;\n\n  const value = (item[separator] ?? []).reduce(\n    (acc, val, _, arr) => {\n      if (\n        '$ref' in val &&\n        existingReferencedProperties.includes(\n          pascal(val.$ref.split('/').pop()!),\n        )\n      ) {\n        if (arr.length === 1) {\n          return 'undefined';\n        }\n\n        return acc;\n      }\n\n      // the required fields in this schema need to be considered\n      // in the sub schema under the allOf key\n      if (separator === 'allOf' && item.required) {\n        if (isSchema(val) && val.required) {\n          val = { ...val, required: [...item.required, ...val.required] };\n        } else {\n          val = { ...val, required: item.required };\n        }\n      }\n\n      const resolvedValue = resolveMockValue({\n        schema: {\n          ...val,\n          name: item.name,\n          path: item.path ? item.path : '#',\n        },\n        combine: {\n          separator,\n          includedProperties:\n            separator !== 'oneOf'\n              ? includedProperties\n              : itemResolvedValue?.includedProperties ?? [],\n        },\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      combineImports.push(...resolvedValue.imports);\n      includedProperties.push(...(resolvedValue.includedProperties ?? []));\n\n      if (resolvedValue.value === '{}') {\n        containsOnlyPrimitiveValues = false;\n        return acc;\n      }\n      if (separator === 'allOf') {\n        if (resolvedValue.value.startsWith('{') || !resolvedValue.type) {\n          containsOnlyPrimitiveValues = false;\n          return `${acc}...${resolvedValue.value},`;\n        } else if (resolvedValue.type === 'object') {\n          containsOnlyPrimitiveValues = false;\n          if (resolvedValue.value.startsWith('faker')) {\n            return `${acc}...${resolvedValue.value},`;\n          } else {\n            return `${acc}...{${resolvedValue.value}},`;\n          }\n        }\n      }\n      return `${acc}${resolvedValue.value},`;\n    },\n    `${separator === 'allOf' ? '' : 'faker.helpers.arrayElement(['}`,\n  );\n  let finalValue =\n    value === 'undefined'\n      ? value\n      : `${separator === 'allOf' && !containsOnlyPrimitiveValues ? '{' : ''}${value}${separator === 'allOf' ? (containsOnlyPrimitiveValues ? '' : '}') : '])'}`;\n  if (itemResolvedValue) {\n    if (finalValue.startsWith('...')) {\n      finalValue = `...{${finalValue}, ${itemResolvedValue.value}}`;\n    } else {\n      finalValue = `{...${finalValue}, ${itemResolvedValue.value}}`;\n    }\n  }\n  if (finalValue.endsWith(',')) {\n    finalValue = finalValue.substring(0, finalValue.length - 1);\n  }\n\n  return {\n    value: finalValue,\n    imports: combineImports,\n    name: item.name,\n    includedProperties,\n  };\n};\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  getRefInfo,\n  isReference,\n  isRootKey,\n  MockOptions,\n  pascal,\n} from '@orval/core';\nimport { SchemaObject } from 'openapi3-ts/oas30';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { overrideVarName } from '../getters';\nimport { getMockScalar } from '../getters/scalar';\n\nconst isRegex = (key: string) => key[0] === '/' && key[key.length - 1] === '/';\n\nexport const resolveMockOverride = (\n  properties: Record<string, unknown> | undefined = {},\n  item: SchemaObject & { name: string; path?: string },\n) => {\n  const path = item.path ? item.path : `#.${item.name}`;\n  const property = Object.entries(properties).find(([key]) => {\n    if (isRegex(key)) {\n      const regex = new RegExp(key.slice(1, key.length - 1));\n      if (regex.test(item.name) || regex.test(path)) {\n        return true;\n      }\n    }\n\n    if (`#.${key}` === path) {\n      return true;\n    }\n\n    return false;\n  });\n\n  if (!property) {\n    return;\n  }\n\n  return {\n    value: getNullable(property[1] as string, item.nullable),\n    imports: [],\n    name: item.name,\n    overrided: true,\n  };\n};\n\nexport const getNullable = (value: string, nullable?: boolean) =>\n  nullable ? `faker.helpers.arrayElement([${value}, null])` : value;\n\nexport const resolveMockValue = ({\n  schema,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride,\n}: {\n  schema: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  allowOverride?: boolean;\n}): MockDefinition & { type?: string } => {\n  if (isReference(schema)) {\n    const {\n      originalName,\n      specKey = context.specKey,\n      refPaths,\n    } = getRefInfo(schema.$ref, context);\n\n    const schemaRef = Array.isArray(refPaths)\n      ? (refPaths.reduce(\n          (obj, key) =>\n            obj && typeof obj === 'object'\n              ? (obj as Record<string, any>)[key]\n              : undefined,\n          context.specs[specKey],\n        ) as Partial<SchemaObject>)\n      : undefined;\n\n    const newSchema = {\n      ...schemaRef,\n      name: pascal(originalName),\n      path: schema.path,\n      isRef: true,\n      required: [...(schemaRef?.required ?? []), ...(schema?.required ?? [])],\n    };\n\n    const newSeparator = newSchema.allOf\n      ? 'allOf'\n      : newSchema.oneOf\n        ? 'oneOf'\n        : 'anyOf';\n\n    const scalar = getMockScalar({\n      item: newSchema,\n      mockOptions,\n      operationId,\n      tags,\n      combine: combine\n        ? {\n            separator:\n              combine.separator === 'anyOf' ? newSeparator : combine.separator,\n            includedProperties:\n              newSeparator === 'allOf' ? [] : combine.includedProperties,\n          }\n        : undefined,\n      context: {\n        ...context,\n        specKey,\n      },\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n      allowOverride,\n    });\n    if (\n      scalar.value &&\n      (newSchema.type === 'object' || newSchema.allOf) &&\n      combine?.separator === 'oneOf'\n    ) {\n      const funcName = `get${pascal(operationId)}Response${pascal(newSchema.name)}Mock`;\n      if (\n        !splitMockImplementations?.some((f) =>\n          f.includes(`export const ${funcName}`),\n        )\n      ) {\n        const discriminatedProperty = newSchema.discriminator?.propertyName;\n\n        let type = `Partial<${newSchema.name}>`;\n        if (discriminatedProperty) {\n          type = `Omit<${type}, '${discriminatedProperty}'>`;\n        }\n\n        const args = `${overrideVarName}: ${type} = {}`;\n        const func = `export const ${funcName} = (${args}): ${newSchema.name} => ({${scalar.value.startsWith('...') ? '' : '...'}${scalar.value}, ...${overrideVarName}});`;\n        splitMockImplementations?.push(func);\n      }\n\n      if (newSchema.nullable) {\n        scalar.value = `${funcName}()`;\n      } else {\n        scalar.value = `{...${funcName}()}`;\n      }\n\n      scalar.imports.push({\n        name: newSchema.name,\n        specKey: isRootKey(specKey, context.target) ? undefined : specKey,\n      });\n    }\n\n    return {\n      ...scalar,\n      type: getType(newSchema),\n    };\n  }\n\n  const scalar = getMockScalar({\n    item: schema,\n    mockOptions,\n    operationId,\n    tags,\n    combine,\n    context,\n    imports,\n    existingReferencedProperties,\n    splitMockImplementations,\n    allowOverride,\n  });\n  return {\n    ...scalar,\n    type: getType(schema),\n  };\n};\n\nconst getType = (schema: MockSchemaObject) => {\n  return (\n    (schema.type as string | undefined) ??\n    (schema.properties ? 'object' : schema.items ? 'array' : undefined)\n  );\n};\n","import {\n  type ContextSpecs,\n  EnumGeneration,\n  escape,\n  type GeneratorImport,\n  isReference,\n  isRootKey,\n  mergeDeep,\n  type MockOptions,\n  pascal,\n} from '@orval/core';\nimport type { SchemaObject as SchemaObject31 } from 'openapi3-ts/oas31';\nimport type { MockDefinition, MockSchemaObject } from '../../types';\nimport { DEFAULT_FORMAT_MOCK } from '../constants';\nimport {\n  getNullable,\n  resolveMockOverride,\n  resolveMockValue,\n} from '../resolvers';\nimport { getMockObject } from './object';\nimport { isFakerVersionV9 } from '../compatibleV9';\n\nexport const getMockScalar = ({\n  item,\n  imports,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  imports: GeneratorImport[];\n  mockOptions?: MockOptions;\n  operationId: string;\n  isRef?: boolean;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  // Add the property to the existing properties to validate on object recursion\n  if (item.isRef) {\n    existingReferencedProperties = [...existingReferencedProperties, item.name];\n  }\n\n  const operationProperty = resolveMockOverride(\n    mockOptions?.operations?.[operationId]?.properties,\n    item,\n  );\n\n  if (operationProperty) {\n    return operationProperty;\n  }\n\n  const overrideTag = Object.entries(mockOptions?.tags ?? {})\n    .sort((a, b) => {\n      return a[0].localeCompare(b[0]);\n    })\n    .reduce(\n      (acc, [tag, options]) =>\n        tags.includes(tag) ? mergeDeep(acc, options) : acc,\n      {} as { properties: Record<string, unknown> },\n    );\n\n  const tagProperty = resolveMockOverride(overrideTag?.properties, item);\n\n  if (tagProperty) {\n    return tagProperty;\n  }\n\n  const property = resolveMockOverride(mockOptions?.properties, item);\n\n  if (property) {\n    return property;\n  }\n\n  if (\n    (context.output.override?.mock?.useExamples || mockOptions?.useExamples) &&\n    item.example !== undefined\n  ) {\n    return {\n      value: JSON.stringify(item.example),\n      imports: [],\n      name: item.name,\n      overrided: true,\n    };\n  }\n\n  const ALL_FORMAT = {\n    ...DEFAULT_FORMAT_MOCK,\n    ...(mockOptions?.format ?? {}),\n  };\n\n  if (item.format && ALL_FORMAT[item.format]) {\n    let value = ALL_FORMAT[item.format] as string;\n\n    const dateFormats = ['date', 'date-time'];\n    if (dateFormats.includes(item.format) && context.output.override.useDates) {\n      value = `new Date(${value})`;\n    }\n\n    return {\n      value: getNullable(value, item.nullable),\n      imports: [],\n      name: item.name,\n      overrided: false,\n    };\n  }\n\n  const type = getItemType(item);\n  const isFakerV9 =\n    !!context.output.packageJson &&\n    isFakerVersionV9(context.output.packageJson);\n\n  switch (type) {\n    case 'number':\n    case 'integer': {\n      const intFunction =\n        item.format === 'int64' && context.output.override.useBigInt\n          ? 'bigInt'\n          : 'int';\n      let value = getNullable(\n        `faker.number.${intFunction}({min: ${item.minimum ?? mockOptions?.numberMin}, max: ${item.maximum ?? mockOptions?.numberMax}${isFakerV9 ? `, multipleOf: ${item.multipleOf}` : ''}})`,\n        item.nullable,\n      );\n      if (type === 'number') {\n        value = getNullable(\n          `faker.number.float({min: ${item.minimum ?? mockOptions?.numberMin}, max: ${item.maximum ?? mockOptions?.numberMax}, ${item.multipleOf ? `multipleOf: ${item.multipleOf}` : `fractionDigits: ${mockOptions?.fractionDigits}`}})`,\n          item.nullable,\n        );\n      }\n      const numberImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          numberImports,\n          context,\n          existingReferencedProperties,\n          'number',\n        );\n      } else if ('const' in item) {\n        value = '' + (item as SchemaObject31).const;\n      }\n\n      return {\n        value,\n        enums: item.enum,\n        imports: numberImports,\n        name: item.name,\n      };\n    }\n\n    case 'boolean': {\n      let value = 'faker.datatype.boolean()';\n      if ('const' in item) {\n        value = '' + (item as SchemaObject31).const;\n      }\n      return {\n        value,\n        imports: [],\n        name: item.name,\n      };\n    }\n\n    case 'array': {\n      if (!item.items) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      if (\n        '$ref' in item.items &&\n        existingReferencedProperties.includes(\n          pascal(item.items.$ref.split('/').pop()!),\n        )\n      ) {\n        return { value: '[]', imports: [], name: item.name };\n      }\n\n      const {\n        value,\n        enums,\n        imports: resolvedImports,\n      } = resolveMockValue({\n        schema: {\n          ...item.items,\n          name: item.name,\n          path: item.path ? `${item.path}.[]` : '#.[]',\n        },\n        combine,\n        mockOptions,\n        operationId,\n        tags,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n      });\n\n      if (enums) {\n        return {\n          value,\n          imports: resolvedImports,\n          name: item.name,\n        };\n      }\n\n      let mapValue = value;\n\n      if (combine && !value.startsWith('faker') && !value.startsWith('{')) {\n        mapValue = `{${value}}`;\n      }\n\n      return {\n        value:\n          `Array.from({ length: faker.number.int({ ` +\n          `min: ${item.minItems ?? mockOptions?.arrayMin}, ` +\n          `max: ${item.maxItems ?? mockOptions?.arrayMax} }) ` +\n          `}, (_, i) => i + 1).map(() => (${mapValue}))`,\n        imports: resolvedImports,\n        name: item.name,\n      };\n    }\n\n    case 'string': {\n      const length = `{length: {min: ${item.minLength ?? mockOptions?.stringMin}, max: ${item.maxLength ?? mockOptions?.stringMax}}}`;\n      let value = `faker.string.alpha(${length})`;\n      const stringImports: GeneratorImport[] = [];\n\n      if (item.enum) {\n        value = getEnum(\n          item,\n          stringImports,\n          context,\n          existingReferencedProperties,\n          'string',\n        );\n      } else if (item.pattern) {\n        value = `faker.helpers.fromRegExp('${item.pattern}')`;\n      } else if ('const' in item) {\n        value = `'${(item as SchemaObject31).const}'`;\n      }\n\n      return {\n        value: getNullable(value, item.nullable),\n        enums: item.enum,\n        name: item.name,\n        imports: stringImports,\n      };\n    }\n\n    case 'null':\n      return {\n        value: 'null',\n        imports: [],\n        name: item.name,\n      };\n\n    default: {\n      if (item.enum) {\n        const enumImports: GeneratorImport[] = [];\n        const value = getEnum(\n          item,\n          enumImports,\n          context,\n          existingReferencedProperties,\n          undefined,\n        );\n\n        return {\n          value,\n          enums: item.enum,\n          imports: enumImports,\n          name: item.name,\n        };\n      }\n\n      return getMockObject({\n        item,\n        mockOptions,\n        operationId,\n        tags,\n        combine: combine\n          ? {\n              separator: combine.separator,\n              includedProperties: [],\n            }\n          : undefined,\n        context,\n        imports,\n        existingReferencedProperties,\n        splitMockImplementations,\n        allowOverride,\n      });\n    }\n  }\n};\n\nfunction getItemType(item: MockSchemaObject) {\n  if (item.type) return item.type;\n  if (!item.enum) return;\n\n  const uniqTypes = new Set(item.enum.map((value) => typeof value));\n  if (uniqTypes.size > 1) return;\n\n  const type = Array.from(uniqTypes.values()).at(0);\n  if (!type) return;\n  return ['string', 'number'].includes(type) ? type : undefined;\n}\n\nconst getEnum = (\n  item: MockSchemaObject,\n  imports: GeneratorImport[],\n  context: ContextSpecs,\n  existingReferencedProperties: string[],\n  type: 'string' | 'number' | undefined,\n) => {\n  if (!item.enum) return '';\n  const joindEnumValues = item.enum\n    .filter((e) => e !== null)\n    .map((e) =>\n      type === 'string' || (type === undefined && typeof e === 'string')\n        ? `'${escape(e)}'`\n        : e,\n    )\n    .join(',');\n\n  let enumValue = `[${joindEnumValues}]`;\n  if (context.output.override.enumGenerationType === EnumGeneration.ENUM) {\n    if (item.isRef || existingReferencedProperties.length === 0) {\n      enumValue += ` as ${item.name}${item.name.endsWith('[]') ? '' : '[]'}`;\n      imports.push({\n        name: item.name,\n        ...(!isRootKey(context.specKey, context.target)\n          ? { specKey: context.specKey }\n          : {}),\n      });\n    } else {\n      enumValue += ` as ${existingReferencedProperties[existingReferencedProperties.length - 1]}['${item.name}']`;\n      if (!item.path?.endsWith('[]')) enumValue += '[]';\n      imports.push({\n        name: existingReferencedProperties[\n          existingReferencedProperties.length - 1\n        ],\n        ...(!isRootKey(context.specKey, context.target)\n          ? { specKey: context.specKey }\n          : {}),\n      });\n    }\n  } else {\n    enumValue += ' as const';\n  }\n\n  // But if the value is a reference, we can use the object directly via the imports and using Object.values.\n  if (item.isRef && type === 'string') {\n    enumValue = `Object.values(${item.name})`;\n    imports.push({\n      name: item.name,\n      values: true,\n      ...(!isRootKey(context.specKey, context.target)\n        ? { specKey: context.specKey }\n        : {}),\n    });\n  }\n\n  return item.path?.endsWith('[]')\n    ? `faker.helpers.arrayElements(${enumValue})`\n    : `faker.helpers.arrayElement(${enumValue})`;\n};\n","import { SchemaObject } from 'openapi3-ts/oas30';\n\nexport const DEFAULT_FORMAT_MOCK: Record<\n  Required<SchemaObject>['format'],\n  string\n> = {\n  bic: 'faker.finance.bic()',\n  binary:\n    \"new Blob(faker.helpers.arrayElements(faker.word.words(10).split(' ')))\",\n  city: 'faker.location.city()',\n  country: 'faker.location.country()',\n  date: \"faker.date.past().toISOString().split('T')[0]\",\n  'date-time': \"`${faker.date.past().toISOString().split('.')[0]}Z`\",\n  email: 'faker.internet.email()',\n  firstName: 'faker.person.firstName()',\n  gender: 'faker.person.gender()',\n  iban: 'faker.finance.iban()',\n  ipv4: 'faker.internet.ipv4()',\n  ipv6: 'faker.internet.ipv6()',\n  jobTitle: 'faker.person.jobTitle()',\n  lastName: 'faker.person.lastName()',\n  password: 'faker.internet.password()',\n  phoneNumber: 'faker.phone.number()',\n  streetName: 'faker.location.street()',\n  uri: 'faker.internet.url()',\n  url: 'faker.internet.url()',\n  userName: 'faker.internet.userName()',\n  uuid: 'faker.string.uuid()',\n  zipCode: 'faker.location.zipCode()',\n};\n\n// #980 replace CUID so tests are consistent\nexport const DEFAULT_OBJECT_KEY_MOCK = 'faker.string.alphanumeric(5)';\n","import {\n  ContextSpecs,\n  GeneratorImport,\n  getKey,\n  isBoolean,\n  isReference,\n  MockOptions,\n  pascal,\n  PropertySortOrder,\n} from '@orval/core';\nimport { ReferenceObject, SchemaObject } from 'openapi3-ts/oas30';\nimport { MockDefinition, MockSchemaObject } from '../../types';\nimport { DEFAULT_OBJECT_KEY_MOCK } from '../constants';\nimport { resolveMockValue } from '../resolvers/value';\nimport { combineSchemasMock } from './combine';\n\nexport const overrideVarName = 'overrideResponse';\n\nexport const getMockObject = ({\n  item,\n  mockOptions,\n  operationId,\n  tags,\n  combine,\n  context,\n  imports,\n  existingReferencedProperties,\n  splitMockImplementations,\n  allowOverride = false,\n}: {\n  item: MockSchemaObject;\n  operationId: string;\n  mockOptions?: MockOptions;\n  tags: string[];\n  combine?: {\n    separator: 'allOf' | 'oneOf' | 'anyOf';\n    includedProperties: string[];\n  };\n  context: ContextSpecs;\n  imports: GeneratorImport[];\n  // This is used to prevent recursion when combining schemas\n  // When an element is added to the array, it means on this iteration, we've already seen this property\n  existingReferencedProperties: string[];\n  splitMockImplementations: string[];\n  // This is used to add the overrideResponse to the object\n  allowOverride?: boolean;\n}): MockDefinition => {\n  if (isReference(item)) {\n    return resolveMockValue({\n      schema: {\n        ...item,\n        name: item.name,\n        path: item.path ? `${item.path}.${item.name}` : item.name,\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.allOf || item.oneOf || item.anyOf) {\n    const separator = item.allOf ? 'allOf' : item.oneOf ? 'oneOf' : 'anyOf';\n    return combineSchemasMock({\n      item,\n      separator,\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (Array.isArray(item.type)) {\n    return combineSchemasMock({\n      item: {\n        anyOf: item.type.map((type) => ({ type })),\n        name: item.name,\n      },\n      separator: 'anyOf',\n      mockOptions,\n      operationId,\n      tags,\n      combine,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n  }\n\n  if (item.properties) {\n    let value =\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '{'\n        : '';\n    const imports: GeneratorImport[] = [];\n    const includedProperties: string[] = [];\n\n    const entries = Object.entries(item.properties);\n    if (context.output.propertySortOrder === PropertySortOrder.ALPHABETICAL) {\n      entries.sort((a, b) => {\n        return a[0].localeCompare(b[0]);\n      });\n    }\n    const properyScalars = entries\n      .map(([key, prop]: [string, ReferenceObject | SchemaObject]) => {\n        if (combine?.includedProperties.includes(key)) {\n          return undefined;\n        }\n\n        const isRequired =\n          mockOptions?.required ||\n          (Array.isArray(item.required) ? item.required : []).includes(key);\n\n        // Check to see if the property is a reference to an existing property\n        // Fixes issue #910\n        if (\n          '$ref' in prop &&\n          existingReferencedProperties.includes(\n            pascal(prop.$ref.split('/').pop()!),\n          )\n        ) {\n          return undefined;\n        }\n\n        const resolvedValue = resolveMockValue({\n          schema: {\n            ...prop,\n            name: key,\n            path: item.path ? `${item.path}.${key}` : `#.${key}`,\n          },\n          mockOptions,\n          operationId,\n          tags,\n          context,\n          imports,\n          existingReferencedProperties,\n          splitMockImplementations,\n        });\n\n        imports.push(...resolvedValue.imports);\n        includedProperties.push(key);\n\n        const keyDefinition = getKey(key);\n        if (!isRequired && !resolvedValue.overrided) {\n          return `${keyDefinition}: faker.helpers.arrayElement([${resolvedValue.value}, undefined])`;\n        }\n\n        return `${keyDefinition}: ${resolvedValue.value}`;\n      })\n      .filter(Boolean);\n\n    if (allowOverride) {\n      properyScalars.push(`...${overrideVarName}`);\n    }\n\n    value += properyScalars.join(', ');\n    value +=\n      !combine ||\n      combine?.separator === 'oneOf' ||\n      combine?.separator === 'anyOf'\n        ? '}'\n        : '';\n\n    return {\n      value,\n      imports,\n      name: item.name,\n      includedProperties,\n    };\n  }\n\n  if (item.additionalProperties) {\n    if (isBoolean(item.additionalProperties)) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n    if (\n      isReference(item.additionalProperties) &&\n      existingReferencedProperties.includes(\n        item.additionalProperties.$ref.split('/').pop()!,\n      )\n    ) {\n      return { value: `{}`, imports: [], name: item.name };\n    }\n\n    const resolvedValue = resolveMockValue({\n      schema: {\n        ...item.additionalProperties,\n        name: item.name,\n        path: item.path ? `${item.path}.#` : '#',\n      },\n      mockOptions,\n      operationId,\n      tags,\n      context,\n      imports,\n      existingReferencedProperties,\n      splitMockImplementations,\n    });\n\n    return {\n      ...resolvedValue,\n      value: `{\n        [${DEFAULT_OBJECT_KEY_MOCK}]: ${resolvedValue.value}\n      }`,\n    };\n  }\n\n  return { value: '{}', imports: [], name: item.name };\n};\n","import { compareVersions, PackageJson } from '@orval/core';\n\nconst getFakerPackageVersion = (packageJson: PackageJson) => {\n  return (\n    packageJson.dependencies?.['@faker-js/faker'] ??\n    packageJson.devDependencies?.['@faker-js/faker'] ??\n    packageJson.peerDependencies?.['@faker-js/faker']\n  );\n};\n\nexport const isFakerVersionV9 = (packageJson: PackageJson) => {\n  const version = getFakerPackageVersion(packageJson);\n\n  if (!version) {\n    return false;\n  }\n\n  const withoutRc = version.split('-')[0];\n\n  return compareVersions(withoutRc, '9.0.0');\n};\n","import { camel, sanitize } from '@orval/core';\n\nconst hasParam = (path: string): boolean => /[^{]*{[\\w*_-]*}.*/.test(path);\n\nconst getRoutePath = (path: string): string => {\n  const matches = path.match(/([^{]*){?([\\w*_-]*)}?(.*)/);\n  if (!matches?.length) return path; // impossible due to regexp grouping here, but for TS\n\n  const prev = matches[1];\n  const param = sanitize(camel(matches[2]), {\n    es5keyword: true,\n    underscore: true,\n    dash: true,\n    dot: true,\n  });\n  const next = hasParam(matches[3]) ? getRoutePath(matches[3]) : matches[3];\n\n  if (hasParam(path)) {\n    return `${prev}:${param}${next}`;\n  } else {\n    return `${prev}${param}${next}`;\n  }\n};\n\nexport const getRouteMSW = (route: string, baseUrl = '*') => {\n  const splittedRoute = route.split('/');\n\n  return splittedRoute.reduce((acc, path, i) => {\n    if (!path && !i) {\n      return acc;\n    }\n\n    if (!path.includes('{')) {\n      return `${acc}/${path}`;\n    }\n\n    return `${acc}/${getRoutePath(path)}`;\n  }, baseUrl);\n};\n","import {\n  ContextSpecs,\n  generalJSTypesWithArray,\n  GeneratorImport,\n  GlobalMockOptions,\n  isFunction,\n  MockOptions,\n  NormalizedOverrideOutput,\n  resolveRef,\n  ResReqTypesValue,\n  stringify,\n} from '@orval/core';\nimport { OpenAPIObject, SchemaObject } from 'openapi3-ts/oas30';\nimport { getMockScalar } from '../faker/getters';\n\nconst getMockPropertiesWithoutFunc = (properties: any, spec: OpenAPIObject) =>\n  Object.entries(isFunction(properties) ? properties(spec) : properties).reduce<\n    Record<string, string>\n  >((acc, [key, value]) => {\n    const implementation = isFunction(value)\n      ? `(${value})()`\n      : stringify(value as string)!;\n\n    acc[key] = implementation?.replace(\n      /import_faker.defaults|import_faker.faker/g,\n      'faker',\n    );\n    return acc;\n  }, {});\n\nconst getMockWithoutFunc = (\n  spec: OpenAPIObject,\n  override?: NormalizedOverrideOutput,\n): MockOptions => ({\n  arrayMin: override?.mock?.arrayMin,\n  arrayMax: override?.mock?.arrayMax,\n  stringMin: override?.mock?.stringMin,\n  stringMax: override?.mock?.stringMax,\n  numberMin: override?.mock?.numberMin,\n  numberMax: override?.mock?.numberMax,\n  required: override?.mock?.required,\n  fractionDigits: override?.mock?.fractionDigits,\n  ...(override?.mock?.properties\n    ? {\n        properties: getMockPropertiesWithoutFunc(\n          override.mock.properties,\n          spec,\n        ),\n      }\n    : {}),\n  ...(override?.mock?.format\n    ? {\n        format: getMockPropertiesWithoutFunc(override.mock.format, spec),\n      }\n    : {}),\n  ...(override?.operations\n    ? {\n        operations: Object.entries(override.operations).reduce<\n          Exclude<MockOptions['operations'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n  ...(override?.tags\n    ? {\n        tags: Object.entries(override.tags).reduce<\n          Exclude<MockOptions['tags'], undefined>\n        >((acc, [key, value]) => {\n          if (value.mock?.properties) {\n            acc[key] = {\n              properties: getMockPropertiesWithoutFunc(\n                value.mock.properties,\n                spec,\n              ),\n            };\n          }\n\n          return acc;\n        }, {}),\n      }\n    : {}),\n});\n\nconst getMockScalarJsTypes = (\n  definition: string,\n  mockOptionsWithoutFunc: { [key: string]: unknown },\n) => {\n  const isArray = definition.endsWith('[]');\n  const type = isArray ? definition.slice(0, -2) : definition;\n\n  switch (type) {\n    case 'number':\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc.arrayMin}, ` +\n            `max: ${mockOptionsWithoutFunc.arrayMax}}` +\n            `)}, () => faker.number.int())`\n        : 'faker.number.int()';\n    case 'string':\n      return isArray\n        ? `Array.from({length: faker.number.int({` +\n            `min: ${mockOptionsWithoutFunc?.arrayMin},` +\n            `max: ${mockOptionsWithoutFunc?.arrayMax}}` +\n            `)}, () => faker.word.sample())`\n        : 'faker.word.sample()';\n    default:\n      return 'undefined';\n  }\n};\n\nexport const getResponsesMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  mockOptionsWithoutFunc,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  mockOptionsWithoutFunc: { [key: string]: unknown };\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  return responses.reduce(\n    (\n      acc,\n      { value: definition, originalSchema, example, examples, imports, isRef },\n    ) => {\n      if (\n        context.output.override?.mock?.useExamples ||\n        mockOptions?.useExamples\n      ) {\n        let exampleValue =\n          example ||\n          originalSchema?.example ||\n          Object.values(examples || {})[0] ||\n          originalSchema?.examples?.[0];\n        exampleValue = exampleValue?.value ?? exampleValue;\n        if (exampleValue) {\n          acc.definitions.push(\n            transformer\n              ? transformer(exampleValue, returnType)\n              : JSON.stringify(exampleValue),\n          );\n          return acc;\n        }\n      }\n      if (!definition || generalJSTypesWithArray.includes(definition)) {\n        const value = getMockScalarJsTypes(definition, mockOptionsWithoutFunc);\n\n        acc.definitions.push(\n          transformer ? transformer(value, returnType) : value,\n        );\n\n        return acc;\n      }\n\n      if (!originalSchema) {\n        return acc;\n      }\n\n      const resolvedRef = resolveRef<SchemaObject>(originalSchema, context);\n\n      const scalar = getMockScalar({\n        item: {\n          name: definition,\n          ...resolvedRef.schema,\n        },\n        imports,\n        mockOptions: mockOptionsWithoutFunc,\n        operationId,\n        tags,\n        context: isRef\n          ? {\n              ...context,\n              specKey: responseImports[0]?.specKey ?? context.specKey,\n            }\n          : context,\n        existingReferencedProperties: [],\n        splitMockImplementations,\n        allowOverride: true,\n      });\n\n      acc.imports.push(...scalar.imports);\n      acc.definitions.push(\n        transformer\n          ? transformer(scalar.value, returnType)\n          : scalar.value.toString(),\n      );\n\n      return acc;\n    },\n    {\n      definitions: [] as string[],\n      imports: [] as GeneratorImport[],\n    },\n  );\n};\n\nexport const getMockDefinition = ({\n  operationId,\n  tags,\n  returnType,\n  responses,\n  imports: responseImports,\n  override,\n  transformer,\n  context,\n  mockOptions,\n  splitMockImplementations,\n}: {\n  operationId: string;\n  tags: string[];\n  returnType: string;\n  responses: ResReqTypesValue[];\n  imports: GeneratorImport[];\n  override: NormalizedOverrideOutput;\n  transformer?: (value: unknown, definition: string) => string;\n  context: ContextSpecs;\n  mockOptions?: GlobalMockOptions;\n  splitMockImplementations: string[];\n}) => {\n  const mockOptionsWithoutFunc = getMockWithoutFunc(\n    context.specs[context.specKey],\n    override,\n  );\n\n  const { definitions, imports } = getResponsesMockDefinition({\n    operationId,\n    tags,\n    returnType,\n    responses,\n    imports: responseImports,\n    mockOptionsWithoutFunc,\n    transformer,\n    context,\n    mockOptions,\n    splitMockImplementations,\n  });\n\n  return {\n    definition: '[' + definitions.join(', ') + ']',\n    definitions,\n    imports,\n  };\n};\n\nexport const getMockOptionsDataOverride = (\n  operationTags: string[],\n  operationId: string,\n  override: NormalizedOverrideOutput,\n) => {\n  const responseOverride =\n    override?.operations?.[operationId]?.mock?.data ||\n    operationTags\n      .map((operationTag) => override?.tags?.[operationTag]?.mock?.data)\n      .find((e) => e !== undefined);\n  const implementation = isFunction(responseOverride)\n    ? `(${responseOverride})()`\n    : stringify(responseOverride);\n\n  return implementation?.replace(\n    /import_faker.defaults|import_faker.faker/g,\n    'faker',\n  );\n};\n"],"mappings":"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","names":["import_core","import_core","import_core","import_core","imports","import_core","scalar","_a","_b","import_core","import_core","_a","_b","_c","exports"]}