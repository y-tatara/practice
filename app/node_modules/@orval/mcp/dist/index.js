"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  builder: () => builder,
  default: () => index_default,
  generateExtraFiles: () => generateExtraFiles,
  generateMcp: () => generateMcp,
  generateServer: () => generateServer,
  getMcpHeader: () => getMcpHeader
});
module.exports = __toCommonJS(index_exports);
var import_core = require("@orval/core");
var import_zod = require("@orval/zod");
var import_fetch = require("@orval/fetch");
var getHeader = (option, info) => {
  if (!option) {
    return "";
  }
  const header = option(info);
  return Array.isArray(header) ? (0, import_core.jsDoc)({ description: header }) : header;
};
var getMcpHeader = ({
  verbOptions,
  output,
  clientImplementation
}) => {
  const targetInfo = (0, import_core.getFileInfo)(output.target);
  const schemaInfo = (0, import_core.getFileInfo)(output.schemas);
  const relativeSchemaImportPath = output.schemas ? import_core.upath.relativeSafe(targetInfo.dirname, schemaInfo.dirname) : "./" + targetInfo.filename + ".schemas";
  const importSchemaNames = Object.values(verbOptions).flatMap((verbOption) => {
    const imports = [];
    const pascalOperationName = (0, import_core.pascal)(verbOption.operationName);
    if (verbOption.queryParams) {
      imports.push(`${pascalOperationName}Params`);
    }
    if (verbOption.body.definition) {
      imports.push(`${pascalOperationName}Body`);
    }
    return imports;
  }).reduce((acc, name) => {
    if (!acc.find((i) => i === name)) {
      acc.push(name);
    }
    return acc;
  }, []);
  const importSchemasImplementation = `import {
  ${importSchemaNames.join(
    ",\n  "
  )}
} from '${relativeSchemaImportPath}';
`;
  const relativeFetchClientPath = "./http-client";
  const importFetchClientNames = Object.values(verbOptions).flatMap((verbOption) => verbOption.operationName).reduce((acc, name) => {
    if (!acc.find((i) => i === name)) {
      acc.push(name);
    }
    return acc;
  }, []);
  const importFetchClientImplementation = `import {
  ${importFetchClientNames.join(
    ",\n  "
  )}
} from '${relativeFetchClientPath}';
  `;
  const content = [
    importSchemasImplementation,
    importFetchClientImplementation
  ].join("\n");
  return content + "\n";
};
var generateMcp = async (verbOptions, options) => {
  const handlerArgsTypes = [];
  const pathParamsType = verbOptions.params.map((param) => {
    const paramName = param.name.split(": ")[0];
    const paramType = param.implementation.split(": ")[1];
    return `    ${paramName}: ${paramType}`;
  }).join(",\n");
  if (pathParamsType) {
    handlerArgsTypes.push(`  pathParams: {
${pathParamsType}
  };`);
  }
  if (verbOptions.queryParams) {
    handlerArgsTypes.push(
      `  queryParams: ${verbOptions.queryParams.schema.name};`
    );
  }
  if (verbOptions.body.definition) {
    handlerArgsTypes.push(`  bodyParams: ${verbOptions.body.definition};`);
  }
  const handlerArgsName = `${verbOptions.operationName}Args`;
  const handlerArgsImplementation = handlerArgsTypes.length ? `
export type ${handlerArgsName} = {
${handlerArgsTypes.join("\n")}
}
` : "";
  const fetchParams = [];
  if (verbOptions.params.length) {
    const pathParamsArgs = verbOptions.params.map((param) => {
      const paramName = param.name.split(": ")[0];
      return `args.pathParams.${paramName}`;
    }).join(", ");
    fetchParams.push(`${pathParamsArgs}`);
  }
  if (verbOptions.body.definition) fetchParams.push(`args.bodyParams`);
  if (verbOptions.queryParams) fetchParams.push(`args.queryParams`);
  const handlerName = `${verbOptions.operationName}Handler`;
  const handlerImplementation = `
export const ${handlerName} = async (${handlerArgsTypes.length ? `args: ${handlerArgsName}` : ""}) => {
  const res = await ${verbOptions.operationName}(${fetchParams.join(", ")});

  return {
    content: [
      {
        type: 'text' as const,
        text: JSON.stringify(res),
      },
    ],
  };
};`;
  const handlersImplementation = [
    handlerArgsImplementation,
    handlerImplementation
  ].join("");
  return {
    implementation: handlersImplementation ? `${handlersImplementation}
` : "",
    imports: []
  };
};
var generateServer = async (verbOptions, output, context) => {
  const info = context.specs[context.specKey].info;
  const { extension, dirname } = (0, import_core.getFileInfo)(output.target);
  const serverPath = import_core.upath.join(dirname, `server${extension}`);
  const header = getHeader(output.override.header, info);
  const toolImplementations = Object.values(verbOptions).map((verbOption) => {
    const imputSchemaTypes = [];
    if (verbOption.params.length)
      imputSchemaTypes.push(
        `  pathParams: ${verbOption.operationName}Params`
      );
    if (verbOption.queryParams)
      imputSchemaTypes.push(
        `  queryParams: ${verbOption.operationName}QueryParams`
      );
    if (verbOption.body.definition)
      imputSchemaTypes.push(`  bodyParams: ${verbOption.operationName}Body`);
    const imputSchemaImplementation = imputSchemaTypes.length ? `  {
  ${imputSchemaTypes.join(",\n  ")}
  },` : "";
    const toolImplementation = `
server.tool(
  '${verbOption.operationName}',
  '${verbOption.summary}',${imputSchemaImplementation ? `
${imputSchemaImplementation}` : ""}
  ${verbOption.operationName}Handler
);`;
    return toolImplementation;
  }).join("\n");
  const importToolSchemas = Object.values(verbOptions).flatMap((verbOption) => {
    const imports = [];
    if (verbOption.headers)
      imports.push(`  ${verbOption.operationName}Header`);
    if (verbOption.params.length)
      imports.push(`  ${verbOption.operationName}Params`);
    if (verbOption.queryParams)
      imports.push(`  ${verbOption.operationName}QueryParams`);
    if (verbOption.body.definition)
      imports.push(`  ${verbOption.operationName}Body`);
    return imports;
  }).join(",\n");
  const importToolSchemasImplementation = `import {
${importToolSchemas}
} from './tool-schemas.zod';`;
  const importHandlers = Object.values(verbOptions).filter(
    (verbOption) => toolImplementations.includes(`${verbOption.operationName}Handler`)
  ).map((verbOption) => `  ${verbOption.operationName}Handler`).join(`,
`);
  const importHandlersImplementation = `import {
${importHandlers}
} from './handlers';`;
  const importDependenciesImplementation = `import {
  McpServer
} from '@modelcontextprotocol/sdk/server/mcp.js';
  
import {
  StdioServerTransport
} from '@modelcontextprotocol/sdk/server/stdio.js';  
`;
  const newMcpServerImplementation = `
const server = new McpServer({
  name: '${(0, import_core.camel)(info.title)}Server',
  version: '1.0.0',
});
`;
  const serverConnectImplementation = `
const transport = new StdioServerTransport();

server.connect(transport).then(() => {
  console.error('MCP server running on stdio');
}).catch(console.error);
`;
  const content = [
    header,
    importDependenciesImplementation,
    importHandlersImplementation,
    importToolSchemasImplementation,
    newMcpServerImplementation,
    toolImplementations,
    serverConnectImplementation
  ].join("\n");
  return [
    {
      content,
      path: serverPath
    }
  ];
};
var generateZodFiles = async (verbOptions, output, context) => {
  const { extension, dirname, filename } = (0, import_core.getFileInfo)(output.target);
  const header = getHeader(
    output.override.header,
    context.specs[context.specKey].info
  );
  const zods = await Promise.all(
    Object.values(verbOptions).map(
      (verbOption) => (0, import_zod.generateZod)(
        verbOption,
        {
          route: verbOption.route,
          pathRoute: verbOption.pathRoute,
          override: output.override,
          context,
          mock: output.mock,
          output: output.target
        },
        output.client
      )
    )
  );
  const allMutators = zods.reduce(
    (acc, z) => {
      var _a;
      ((_a = z.mutators) != null ? _a : []).forEach((mutator) => {
        acc[mutator.name] = mutator;
      });
      return acc;
    },
    {}
  );
  const mutatorsImports = (0, import_core.generateMutatorImports)({
    mutators: Object.values(allMutators)
  });
  let content = `${header}import { z as zod } from 'zod';
${mutatorsImports}
`;
  const zodPath = import_core.upath.join(dirname, `tool-schemas.zod${extension}`);
  content += zods.map((zod) => zod.implementation).join("\n");
  return [
    {
      content,
      path: zodPath
    }
  ];
};
var generateHttpClinetFiles = async (verbOptions, output, context) => {
  const { extension, dirname, filename } = (0, import_core.getFileInfo)(output.target);
  const header = getHeader(
    output.override.header,
    context.specs[context.specKey].info
  );
  const clients = await Promise.all(
    Object.values(verbOptions).map((verbOption) => {
      const fullRoute = (0, import_core.getFullRoute)(
        verbOption.route,
        context.specs[context.specKey].servers,
        output.baseUrl
      );
      const options = {
        route: fullRoute,
        pathRoute: verbOption.pathRoute,
        override: output.override,
        context,
        mock: output.mock,
        output: output.target
      };
      return (0, import_fetch.generateClient)(verbOption, options, output.client, output);
    })
  );
  const clientImplementation = clients.map((client) => client.implementation).join("\n");
  const relativeSchemasPath = output.schemas ? import_core.upath.relativeSafe(dirname, (0, import_core.getFileInfo)(output.schemas).dirname) : "./" + filename + ".schemas";
  const importNames = clients.flatMap((client) => client.imports).reduce((acc, imp) => {
    if (!acc.find((i) => i === imp.name)) {
      acc.push(imp.name);
    }
    return acc;
  }, []);
  const importImplementation = `import { ${importNames.join(
    ",\n"
  )} } from '${relativeSchemasPath}';`;
  const fetchHeader = (0, import_fetch.generateFetchHeader)({
    title: "",
    isRequestOptions: false,
    isMutator: false,
    noFunction: false,
    isGlobalMutator: false,
    provideIn: false,
    hasAwaitedType: false,
    output,
    verbOptions,
    clientImplementation
  });
  const content = [
    header,
    importImplementation,
    fetchHeader,
    clientImplementation
  ].join("\n");
  const outputPath = import_core.upath.join(dirname, `http-client${extension}`);
  return [
    {
      content,
      path: outputPath
    }
  ];
};
var generateExtraFiles = async (verbOptions, output, context) => {
  const [server, zods, httpClients] = await Promise.all([
    generateServer(verbOptions, output, context),
    generateZodFiles(verbOptions, output, context),
    generateHttpClinetFiles(verbOptions, output, context)
  ]);
  return [...server, ...zods, ...httpClients];
};
var mcpClientBuilder = {
  client: generateMcp,
  header: getMcpHeader,
  extraFiles: generateExtraFiles
};
var builder = () => () => mcpClientBuilder;
var index_default = builder;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  builder,
  generateExtraFiles,
  generateMcp,
  generateServer,
  getMcpHeader
});
//# sourceMappingURL=index.js.map