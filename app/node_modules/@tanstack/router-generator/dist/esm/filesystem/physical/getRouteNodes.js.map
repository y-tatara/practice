{"version":3,"file":"getRouteNodes.js","sources":["../../../../src/filesystem/physical/getRouteNodes.ts"],"sourcesContent":["import path from 'node:path'\nimport * as fsp from 'node:fs/promises'\nimport {\n  determineInitialRoutePath,\n  removeExt,\n  replaceBackslash,\n  routePathToVariable,\n} from '../../utils'\nimport { getRouteNodes as getRouteNodesVirtual } from '../virtual/getRouteNodes'\nimport { loadConfigFile } from '../virtual/loadConfigFile'\nimport { logging } from '../../logger'\nimport { rootPathId } from './rootPathId'\nimport type {\n  VirtualRootRoute,\n  VirtualRouteSubtreeConfig,\n} from '@tanstack/virtual-file-routes'\nimport type { FsRouteType, GetRouteNodesResult, RouteNode } from '../../types'\nimport type { Config } from '../../config'\n\nconst disallowedRouteGroupConfiguration = /\\(([^)]+)\\).(ts|js|tsx|jsx)/\n\nconst virtualConfigFileRegExp = /__virtual\\.[mc]?[jt]s$/\nexport function isVirtualConfigFile(fileName: string): boolean {\n  return virtualConfigFileRegExp.test(fileName)\n}\n\nexport async function getRouteNodes(\n  config: Pick<\n    Config,\n    | 'routesDirectory'\n    | 'routeFilePrefix'\n    | 'routeFileIgnorePrefix'\n    | 'routeFileIgnorePattern'\n    | 'disableLogging'\n    | 'routeToken'\n    | 'indexToken'\n  >,\n  root: string,\n): Promise<GetRouteNodesResult> {\n  const { routeFilePrefix, routeFileIgnorePrefix, routeFileIgnorePattern } =\n    config\n\n  const logger = logging({ disabled: config.disableLogging })\n  const routeFileIgnoreRegExp = new RegExp(routeFileIgnorePattern ?? '', 'g')\n\n  const routeNodes: Array<RouteNode> = []\n  const allPhysicalDirectories: Array<string> = []\n\n  async function recurse(dir: string) {\n    const fullDir = path.resolve(config.routesDirectory, dir)\n    let dirList = await fsp.readdir(fullDir, { withFileTypes: true })\n\n    dirList = dirList.filter((d) => {\n      if (\n        d.name.startsWith('.') ||\n        (routeFileIgnorePrefix && d.name.startsWith(routeFileIgnorePrefix))\n      ) {\n        return false\n      }\n\n      if (routeFilePrefix) {\n        if (routeFileIgnorePattern) {\n          return (\n            d.name.startsWith(routeFilePrefix) &&\n            !d.name.match(routeFileIgnoreRegExp)\n          )\n        }\n\n        return d.name.startsWith(routeFilePrefix)\n      }\n\n      if (routeFileIgnorePattern) {\n        return !d.name.match(routeFileIgnoreRegExp)\n      }\n\n      return true\n    })\n\n    const virtualConfigFile = dirList.find((dirent) => {\n      return dirent.isFile() && isVirtualConfigFile(dirent.name)\n    })\n\n    if (virtualConfigFile !== undefined) {\n      const virtualRouteConfigExport = await loadConfigFile(\n        path.resolve(fullDir, virtualConfigFile.name),\n      )\n      let virtualRouteSubtreeConfig: VirtualRouteSubtreeConfig\n      if (typeof virtualRouteConfigExport.default === 'function') {\n        virtualRouteSubtreeConfig = await virtualRouteConfigExport.default()\n      } else {\n        virtualRouteSubtreeConfig = virtualRouteConfigExport.default\n      }\n      const dummyRoot: VirtualRootRoute = {\n        type: 'root',\n        file: '',\n        children: virtualRouteSubtreeConfig,\n      }\n      const { routeNodes: virtualRouteNodes, physicalDirectories } =\n        await getRouteNodesVirtual(\n          {\n            ...config,\n            routesDirectory: fullDir,\n            virtualRouteConfig: dummyRoot,\n          },\n          root,\n        )\n      allPhysicalDirectories.push(...physicalDirectories)\n      virtualRouteNodes.forEach((node) => {\n        const filePath = replaceBackslash(path.join(dir, node.filePath))\n        const routePath = `/${dir}${node.routePath}`\n\n        node.variableName = routePathToVariable(\n          `${dir}/${removeExt(node.filePath)}`,\n        )\n        node.routePath = routePath\n        node.filePath = filePath\n      })\n\n      routeNodes.push(...virtualRouteNodes)\n\n      return\n    }\n\n    await Promise.all(\n      dirList.map(async (dirent) => {\n        const fullPath = replaceBackslash(path.join(fullDir, dirent.name))\n        const relativePath = path.posix.join(dir, dirent.name)\n\n        if (dirent.isDirectory()) {\n          await recurse(relativePath)\n        } else if (fullPath.match(/\\.(tsx|ts|jsx|js)$/)) {\n          const filePath = replaceBackslash(path.join(dir, dirent.name))\n          const filePathNoExt = removeExt(filePath)\n          let routePath = determineInitialRoutePath(filePathNoExt)\n\n          if (routeFilePrefix) {\n            routePath = routePath.replaceAll(routeFilePrefix, '')\n          }\n\n          if (disallowedRouteGroupConfiguration.test(dirent.name)) {\n            const errorMessage = `A route configuration for a route group was found at \\`${filePath}\\`. This is not supported. Did you mean to use a layout/pathless route instead?`\n            logger.error(`ERROR: ${errorMessage}`)\n            throw new Error(errorMessage)\n          }\n\n          const meta = getRouteMeta(routePath, config)\n          const variableName = meta.variableName\n          let routeType: FsRouteType = meta.fsRouteType\n\n          if (routeType === 'lazy') {\n            routePath = routePath.replace(/\\/lazy$/, '')\n          }\n\n          // this check needs to happen after the lazy route has been cleaned up\n          // since the routePath is used to determine if a route is pathless\n          if (isValidPathlessLayoutRoute(routePath, routeType, config)) {\n            routeType = 'pathless_layout'\n          }\n\n          ;(\n            [\n              ['component', 'component'],\n              ['errorComponent', 'errorComponent'],\n              ['pendingComponent', 'pendingComponent'],\n              ['loader', 'loader'],\n            ] satisfies Array<[FsRouteType, string]>\n          ).forEach(([matcher, type]) => {\n            if (routeType === matcher) {\n              logger.warn(\n                `WARNING: The \\`.${type}.tsx\\` suffix used for the ${filePath} file is deprecated. Use the new \\`.lazy.tsx\\` suffix instead.`,\n              )\n            }\n          })\n\n          routePath = routePath.replace(\n            new RegExp(\n              `/(component|errorComponent|pendingComponent|loader|${config.routeToken}|lazy)$`,\n            ),\n            '',\n          )\n\n          if (routePath === config.indexToken) {\n            routePath = '/'\n          }\n\n          routePath =\n            routePath.replace(new RegExp(`/${config.indexToken}$`), '/') || '/'\n\n          routeNodes.push({\n            filePath,\n            fullPath,\n            routePath,\n            variableName,\n            _fsRouteType: routeType,\n          })\n        }\n      }),\n    )\n\n    return routeNodes\n  }\n\n  await recurse('./')\n\n  const rootRouteNode = routeNodes.find((d) => d.routePath === `/${rootPathId}`)\n  if (rootRouteNode) {\n    rootRouteNode._fsRouteType = '__root'\n    rootRouteNode.variableName = 'root'\n  }\n\n  return {\n    rootRouteNode,\n    routeNodes,\n    physicalDirectories: allPhysicalDirectories,\n  }\n}\n\n/**\n * Determines the metadata for a given route path based on the provided configuration.\n *\n * @param routePath - The determined initial routePath.\n * @param config - The user configuration object.\n * @returns An object containing the type of the route and the variable name derived from the route path.\n */\nexport function getRouteMeta(\n  routePath: string,\n  config: Pick<Config, 'routeToken' | 'indexToken'>,\n): {\n  // `__root` is can be more easily determined by filtering down to routePath === /${rootPathId}\n  // `pathless` is needs to determined after `lazy` has been cleaned up from the routePath\n  fsRouteType: Extract<\n    FsRouteType,\n    | 'static'\n    | 'layout'\n    | 'api'\n    | 'lazy'\n    | 'loader'\n    | 'component'\n    | 'pendingComponent'\n    | 'errorComponent'\n  >\n  variableName: string\n} {\n  let fsRouteType: FsRouteType = 'static'\n\n  if (routePath.endsWith(`/${config.routeToken}`)) {\n    // layout routes, i.e `/foo/route.tsx` or `/foo/_layout/route.tsx`\n    fsRouteType = 'layout'\n  } else if (routePath.endsWith('/lazy')) {\n    // lazy routes, i.e. `/foo.lazy.tsx`\n    fsRouteType = 'lazy'\n  } else if (routePath.endsWith('/loader')) {\n    // loader routes, i.e. `/foo.loader.tsx`\n    fsRouteType = 'loader'\n  } else if (routePath.endsWith('/component')) {\n    // component routes, i.e. `/foo.component.tsx`\n    fsRouteType = 'component'\n  } else if (routePath.endsWith('/pendingComponent')) {\n    // pending component routes, i.e. `/foo.pendingComponent.tsx`\n    fsRouteType = 'pendingComponent'\n  } else if (routePath.endsWith('/errorComponent')) {\n    // error component routes, i.e. `/foo.errorComponent.tsx`\n    fsRouteType = 'errorComponent'\n  }\n\n  const variableName = routePathToVariable(routePath)\n\n  return { fsRouteType, variableName }\n}\n\n/**\n * Used to validate if a route is a pathless layout route\n * @param normalizedRoutePath Normalized route path, i.e `/foo/_layout/route.tsx` and `/foo._layout.route.tsx` to `/foo/_layout/route`\n * @param config The `router-generator` configuration object\n * @returns Boolean indicating if the route is a pathless layout route\n */\nfunction isValidPathlessLayoutRoute(\n  normalizedRoutePath: string,\n  routeType: FsRouteType,\n  config: Pick<Config, 'routeToken' | 'indexToken'>,\n): boolean {\n  if (routeType === 'lazy') {\n    return false\n  }\n\n  const segments = normalizedRoutePath.split('/').filter(Boolean)\n\n  if (segments.length === 0) {\n    return false\n  }\n\n  const lastRouteSegment = segments[segments.length - 1]!\n  const secondToLastRouteSegment = segments[segments.length - 2]\n\n  // If segment === __root, then exit as false\n  if (lastRouteSegment === rootPathId) {\n    return false\n  }\n\n  // If segment === config.routeToken and secondToLastSegment is a string that starts with _, then exit as true\n  // Since the route is actually a configuration route for a layout/pathless route\n  // i.e. /foo/_layout/route.tsx === /foo/_layout.tsx\n  if (\n    lastRouteSegment === config.routeToken &&\n    typeof secondToLastRouteSegment === 'string'\n  ) {\n    return secondToLastRouteSegment.startsWith('_')\n  }\n\n  // Segment starts with _\n  return (\n    lastRouteSegment !== config.indexToken &&\n    lastRouteSegment !== config.routeToken &&\n    lastRouteSegment.startsWith('_')\n  )\n}\n"],"names":["getRouteNodesVirtual"],"mappings":"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"}