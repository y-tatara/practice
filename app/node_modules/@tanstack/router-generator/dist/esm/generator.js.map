{"version":3,"file":"generator.js","sources":["../../src/generator.ts"],"sourcesContent":["import path from 'node:path'\nimport * as fsp from 'node:fs/promises'\nimport { mkdirSync } from 'node:fs'\nimport crypto from 'node:crypto'\nimport { deepEqual, rootRouteId } from '@tanstack/router-core'\nimport { logging } from './logger'\nimport {\n  isVirtualConfigFile,\n  getRouteNodes as physicalGetRouteNodes,\n} from './filesystem/physical/getRouteNodes'\nimport { getRouteNodes as virtualGetRouteNodes } from './filesystem/virtual/getRouteNodes'\nimport { rootPathId } from './filesystem/physical/rootPathId'\nimport {\n  buildFileRoutesByPathInterface,\n  buildImportString,\n  buildRouteTreeConfig,\n  checkFileExists,\n  createRouteNodesByFullPath,\n  createRouteNodesById,\n  createRouteNodesByTo,\n  determineNodePath,\n  findParent,\n  format,\n  getResolvedRouteNodeVariableName,\n  hasParentRoute,\n  isRouteNodeValidForAugmentation,\n  lowerCaseFirstChar,\n  mergeImportDeclarations,\n  multiSortBy,\n  removeExt,\n  removeGroups,\n  removeLastSegmentFromPath,\n  removeLayoutSegments,\n  removeUnderscores,\n  replaceBackslash,\n  resetRegex,\n  routePathToVariable,\n  trimPathLeft,\n} from './utils'\nimport { fillTemplate, getTargetTemplate } from './template'\nimport { transform } from './transform/transform'\nimport { defaultGeneratorPlugin } from './plugin/default-generator-plugin'\nimport type {\n  GeneratorPlugin,\n  GeneratorPluginWithTransform,\n} from './plugin/types'\nimport type { TargetTemplate } from './template'\nimport type {\n  FsRouteType,\n  GetRouteNodesResult,\n  GetRoutesByFileMapResult,\n  HandleNodeAccumulator,\n  ImportDeclaration,\n  RouteNode,\n} from './types'\nimport type { Config } from './config'\nimport type { Logger } from './logger'\nimport type { TransformPlugin } from './transform/types'\n\ninterface fs {\n  stat: (\n    filePath: string,\n  ) => Promise<{ mtimeMs: bigint; mode: number; uid: number; gid: number }>\n  rename: (oldPath: string, newPath: string) => Promise<void>\n  writeFile: (filePath: string, content: string) => Promise<void>\n  readFile: (\n    filePath: string,\n  ) => Promise<\n    { stat: { mtimeMs: bigint }; fileContent: string } | 'file-not-existing'\n  >\n  chmod: (filePath: string, mode: number) => Promise<void>\n  chown: (filePath: string, uid: number, gid: number) => Promise<void>\n}\n\nconst DefaultFileSystem: fs = {\n  stat: async (filePath) => {\n    const res = await fsp.stat(filePath, { bigint: true })\n    return {\n      mtimeMs: res.mtimeMs,\n      mode: Number(res.mode),\n      uid: Number(res.uid),\n      gid: Number(res.gid),\n    }\n  },\n  rename: (oldPath, newPath) => fsp.rename(oldPath, newPath),\n  writeFile: (filePath, content) => fsp.writeFile(filePath, content),\n  readFile: async (filePath: string) => {\n    try {\n      const fileHandle = await fsp.open(filePath, 'r')\n      const stat = await fileHandle.stat({ bigint: true })\n      const fileContent = (await fileHandle.readFile()).toString()\n      await fileHandle.close()\n      return { stat, fileContent }\n    } catch (e: any) {\n      if ('code' in e) {\n        if (e.code === 'ENOENT') {\n          return 'file-not-existing'\n        }\n      }\n      throw e\n    }\n  },\n  chmod: (filePath, mode) => fsp.chmod(filePath, mode),\n  chown: (filePath, uid, gid) => fsp.chown(filePath, uid, gid),\n}\n\ninterface Rerun {\n  rerun: true\n  msg?: string\n  event: GeneratorEvent\n}\nfunction rerun(opts: { msg?: string; event?: GeneratorEvent }): Rerun {\n  const { event, ...rest } = opts\n  return { rerun: true, event: event ?? { type: 'rerun' }, ...rest }\n}\n\nfunction isRerun(result: unknown): result is Rerun {\n  return (\n    typeof result === 'object' &&\n    result !== null &&\n    'rerun' in result &&\n    result.rerun === true\n  )\n}\n\nexport type FileEventType = 'create' | 'update' | 'delete'\nexport type FileEvent = {\n  type: FileEventType\n  path: string\n}\nexport type GeneratorEvent = FileEvent | { type: 'rerun' }\n\ntype FileCacheChange<TCacheEntry extends GeneratorCacheEntry> =\n  | {\n      result: false\n      cacheEntry: TCacheEntry\n    }\n  | { result: true; mtimeMs: bigint; cacheEntry: TCacheEntry }\n  | {\n      result: 'file-not-in-cache'\n    }\n  | {\n      result: 'cannot-stat-file'\n    }\n\ninterface GeneratorCacheEntry {\n  mtimeMs: bigint\n  fileContent: string\n}\n\ninterface RouteNodeCacheEntry extends GeneratorCacheEntry {\n  exports: Array<string>\n  routeId: string\n}\n\ntype GeneratorRouteNodeCache = Map</** filePath **/ string, RouteNodeCacheEntry>\n\nexport class Generator {\n  /**\n   * why do we have two caches for the route files?\n   * During processing, we READ from the cache and WRITE to the shadow cache.\n   *\n   * After a route file is processed, we write to the shadow cache.\n   * If during processing we bail out and re-run, we don't lose this modification\n   * but still can track whether the file contributed changes and thus the route tree file needs to be regenerated.\n   * After all files are processed, we swap the shadow cache with the main cache and initialize a new shadow cache.\n   * That way we also ensure deleted/renamed files don't stay in the cache forever.\n   */\n  private routeNodeCache: GeneratorRouteNodeCache = new Map()\n  private routeNodeShadowCache: GeneratorRouteNodeCache = new Map()\n\n  private routeTreeFileCache: GeneratorCacheEntry | undefined\n\n  public config: Config\n  public targetTemplate: TargetTemplate\n\n  private root: string\n  private routesDirectoryPath: string\n  private sessionId?: string\n  private fs: fs\n  private logger: Logger\n  private generatedRouteTreePath: string\n  private runPromise: Promise<void> | undefined\n  private fileEventQueue: Array<GeneratorEvent> = []\n  private plugins: Array<GeneratorPlugin> = [defaultGeneratorPlugin()]\n  private pluginsWithTransform: Array<GeneratorPluginWithTransform> = []\n  // this is just a cache for the transform plugins since we need them for each route file that is to be processed\n  private transformPlugins: Array<TransformPlugin> = []\n  private routeGroupPatternRegex = /\\(.+\\)/g\n  private physicalDirectories: Array<string> = []\n\n  constructor(opts: { config: Config; root: string; fs?: fs }) {\n    this.config = opts.config\n    this.logger = logging({ disabled: this.config.disableLogging })\n    this.root = opts.root\n    this.fs = opts.fs || DefaultFileSystem\n    this.generatedRouteTreePath = path.resolve(this.config.generatedRouteTree)\n    this.targetTemplate = getTargetTemplate(this.config)\n\n    this.routesDirectoryPath = this.getRoutesDirectoryPath()\n    this.plugins.push(...(opts.config.plugins || []))\n    this.plugins.forEach((plugin) => {\n      if ('transformPlugin' in plugin) {\n        if (this.pluginsWithTransform.find((p) => p.name === plugin.name)) {\n          throw new Error(\n            `Plugin with name \"${plugin.name}\" is already registered for export ${plugin.transformPlugin.exportName}!`,\n          )\n        }\n        this.pluginsWithTransform.push(plugin)\n        this.transformPlugins.push(plugin.transformPlugin)\n      }\n    })\n  }\n\n  private getRoutesDirectoryPath() {\n    return path.isAbsolute(this.config.routesDirectory)\n      ? this.config.routesDirectory\n      : path.resolve(this.root, this.config.routesDirectory)\n  }\n\n  public getRoutesByFileMap(): GetRoutesByFileMapResult {\n    return new Map(\n      [...this.routeNodeCache.entries()].map(([filePath, cacheEntry]) => [\n        filePath,\n        { routePath: cacheEntry.routeId },\n      ]),\n    )\n  }\n\n  public async run(event?: GeneratorEvent): Promise<void> {\n    if (\n      event &&\n      event.type !== 'rerun' &&\n      !this.isFileRelevantForRouteTreeGeneration(event.path)\n    ) {\n      return\n    }\n    this.fileEventQueue.push(event ?? { type: 'rerun' })\n    // only allow a single run at a time\n    if (this.runPromise) {\n      return this.runPromise\n    }\n\n    this.runPromise = (async () => {\n      do {\n        // synchronously copy and clear the queue since we are going to iterate asynchronously over it\n        // and while we do so, a new event could be put into the queue\n        const tempQueue = this.fileEventQueue\n        this.fileEventQueue = []\n        // if we only have 'update' events in the queue\n        // and we already have the affected files' latest state in our cache, we can exit early\n        const remainingEvents = (\n          await Promise.all(\n            tempQueue.map(async (e) => {\n              if (e.type === 'update') {\n                let cacheEntry: GeneratorCacheEntry | undefined\n                if (e.path === this.generatedRouteTreePath) {\n                  cacheEntry = this.routeTreeFileCache\n                } else {\n                  // we only check the routeNodeCache here\n                  // if the file's state is only up-to-date in the shadow cache we need to re-run\n                  cacheEntry = this.routeNodeCache.get(e.path)\n                }\n                const change = await this.didFileChangeComparedToCache(\n                  { path: e.path },\n                  cacheEntry,\n                )\n                if (change.result === false) {\n                  return null\n                }\n              }\n              return e\n            }),\n          )\n        ).filter((e) => e !== null)\n\n        if (remainingEvents.length === 0) {\n          break\n        }\n\n        try {\n          const start = performance.now()\n          await this.generatorInternal()\n          const end = performance.now()\n          this.logger.info(\n            `Generated route tree in ${Math.round(end - start)}ms`,\n          )\n        } catch (err) {\n          const errArray = !Array.isArray(err) ? [err] : err\n\n          const recoverableErrors = errArray.filter((e) => isRerun(e))\n          if (recoverableErrors.length === errArray.length) {\n            this.fileEventQueue.push(...recoverableErrors.map((e) => e.event))\n            recoverableErrors.forEach((e) => {\n              if (e.msg) {\n                this.logger.info(e.msg)\n              }\n            })\n          } else {\n            const unrecoverableErrors = errArray.filter((e) => !isRerun(e))\n            this.runPromise = undefined\n            throw new Error(\n              unrecoverableErrors.map((e) => (e as Error).message).join(),\n            )\n          }\n        }\n      } while (this.fileEventQueue.length)\n      this.runPromise = undefined\n    })()\n    return this.runPromise\n  }\n\n  private async generatorInternal() {\n    let writeRouteTreeFile: boolean | 'force' = false\n\n    let getRouteNodesResult: GetRouteNodesResult\n\n    if (this.config.virtualRouteConfig) {\n      getRouteNodesResult = await virtualGetRouteNodes(this.config, this.root)\n    } else {\n      getRouteNodesResult = await physicalGetRouteNodes(this.config, this.root)\n    }\n\n    const {\n      rootRouteNode,\n      routeNodes: beforeRouteNodes,\n      physicalDirectories,\n    } = getRouteNodesResult\n    if (rootRouteNode === undefined) {\n      let errorMessage = `rootRouteNode must not be undefined. Make sure you've added your root route into the route-tree.`\n      if (!this.config.virtualRouteConfig) {\n        errorMessage += `\\nMake sure that you add a \"${rootPathId}.${this.config.disableTypes ? 'js' : 'tsx'}\" file to your routes directory.\\nAdd the file in: \"${this.config.routesDirectory}/${rootPathId}.${this.config.disableTypes ? 'js' : 'tsx'}\"`\n      }\n      throw new Error(errorMessage)\n    }\n    this.physicalDirectories = physicalDirectories\n\n    writeRouteTreeFile = await this.handleRootNode(rootRouteNode)\n\n    const preRouteNodes = multiSortBy(beforeRouteNodes, [\n      (d) => (d.routePath === '/' ? -1 : 1),\n      (d) => d.routePath?.split('/').length,\n      (d) =>\n        d.filePath.match(new RegExp(`[./]${this.config.indexToken}[.]`))\n          ? 1\n          : -1,\n      (d) =>\n        d.filePath.match(\n          /[./](component|errorComponent|pendingComponent|loader|lazy)[.]/,\n        )\n          ? 1\n          : -1,\n      (d) =>\n        d.filePath.match(new RegExp(`[./]${this.config.routeToken}[.]`))\n          ? -1\n          : 1,\n      (d) => (d.routePath?.endsWith('/') ? -1 : 1),\n      (d) => d.routePath,\n    ]).filter((d) => ![`/${rootPathId}`].includes(d.routePath || ''))\n\n    const routeFileAllResult = await Promise.allSettled(\n      preRouteNodes\n        // only process routes that are backed by an actual file\n        .filter((n) => !n.isVirtualParentRoute && !n.isVirtual)\n        .map((n) => this.processRouteNodeFile(n)),\n    )\n\n    const rejections = routeFileAllResult.filter(\n      (result) => result.status === 'rejected',\n    )\n    if (rejections.length > 0) {\n      throw rejections.map((e) => e.reason)\n    }\n\n    const routeFileResult = routeFileAllResult.flatMap((result) => {\n      if (result.status === 'fulfilled' && result.value !== null) {\n        return result.value\n      }\n      return []\n    })\n\n    routeFileResult.forEach((result) => {\n      if (!result.node.exports?.length) {\n        this.logger.warn(\n          `Route file \"${result.cacheEntry.fileContent}\" does not export any route piece. This is likely a mistake.`,\n        )\n      }\n    })\n    if (routeFileResult.find((r) => r.shouldWriteTree)) {\n      writeRouteTreeFile = true\n    }\n\n    // this is the first time the generator runs, so read in the route tree file if it exists yet\n    if (!this.routeTreeFileCache) {\n      const routeTreeFile = await this.fs.readFile(this.generatedRouteTreePath)\n      if (routeTreeFile !== 'file-not-existing') {\n        this.routeTreeFileCache = {\n          fileContent: routeTreeFile.fileContent,\n          mtimeMs: routeTreeFile.stat.mtimeMs,\n        }\n      }\n      writeRouteTreeFile = true\n    } else {\n      const routeTreeFileChange = await this.didFileChangeComparedToCache(\n        { path: this.generatedRouteTreePath },\n        this.routeTreeFileCache,\n      )\n      if (routeTreeFileChange.result !== false) {\n        writeRouteTreeFile = 'force'\n        if (routeTreeFileChange.result === true) {\n          const routeTreeFile = await this.fs.readFile(\n            this.generatedRouteTreePath,\n          )\n          if (routeTreeFile !== 'file-not-existing') {\n            this.routeTreeFileCache = {\n              fileContent: routeTreeFile.fileContent,\n              mtimeMs: routeTreeFile.stat.mtimeMs,\n            }\n          }\n        }\n      }\n    }\n\n    if (!writeRouteTreeFile) {\n      // only needs to be done if no other changes have been detected yet\n      // compare shadowCache and cache to identify deleted routes\n      for (const fullPath of this.routeNodeCache.keys()) {\n        if (!this.routeNodeShadowCache.has(fullPath)) {\n          writeRouteTreeFile = true\n          break\n        }\n      }\n    }\n\n    if (!writeRouteTreeFile) {\n      this.swapCaches()\n      return\n    }\n\n    let routeTreeContent = this.buildRouteTreeFileContent(\n      rootRouteNode,\n      preRouteNodes,\n      routeFileResult,\n    )\n    routeTreeContent = this.config.enableRouteTreeFormatting\n      ? await format(routeTreeContent, this.config)\n      : routeTreeContent\n\n    let newMtimeMs: bigint | undefined\n    if (this.routeTreeFileCache) {\n      if (\n        writeRouteTreeFile !== 'force' &&\n        this.routeTreeFileCache.fileContent === routeTreeContent\n      ) {\n        // existing route tree file is already up-to-date, don't write it\n        // we should only get here in the initial run when the route cache is not filled yet\n      } else {\n        const newRouteTreeFileStat = await this.safeFileWrite({\n          filePath: this.generatedRouteTreePath,\n          newContent: routeTreeContent,\n          strategy: {\n            type: 'mtime',\n            expectedMtimeMs: this.routeTreeFileCache.mtimeMs,\n          },\n        })\n        newMtimeMs = newRouteTreeFileStat.mtimeMs\n      }\n    } else {\n      const newRouteTreeFileStat = await this.safeFileWrite({\n        filePath: this.generatedRouteTreePath,\n        newContent: routeTreeContent,\n        strategy: {\n          type: 'new-file',\n        },\n      })\n      newMtimeMs = newRouteTreeFileStat.mtimeMs\n    }\n\n    if (newMtimeMs !== undefined) {\n      this.routeTreeFileCache = {\n        fileContent: routeTreeContent,\n        mtimeMs: newMtimeMs,\n      }\n    }\n\n    this.swapCaches()\n  }\n\n  private swapCaches() {\n    this.routeNodeCache = this.routeNodeShadowCache\n    this.routeNodeShadowCache = new Map()\n  }\n\n  private buildRouteTreeFileContent(\n    rootRouteNode: RouteNode,\n    preRouteNodes: Array<RouteNode>,\n    routeFileResult: Array<{\n      cacheEntry: RouteNodeCacheEntry\n      node: RouteNode\n    }>,\n  ) {\n    const getImportForRouteNode = (node: RouteNode, exportName: string) => {\n      if (node.exports?.includes(exportName)) {\n        return {\n          source: `./${this.getImportPath(node)}`,\n          specifiers: [\n            {\n              imported: exportName,\n              local: `${node.variableName}${exportName}Import`,\n            },\n          ],\n        } satisfies ImportDeclaration\n      }\n      return undefined\n    }\n\n    const buildRouteTreeForExport = (plugin: GeneratorPluginWithTransform) => {\n      const exportName = plugin.transformPlugin.exportName\n      const acc: HandleNodeAccumulator = {\n        routeTree: [],\n        routeNodes: [],\n        routePiecesByPath: {},\n      }\n      for (const node of preRouteNodes) {\n        if (node.exports?.includes(plugin.transformPlugin.exportName)) {\n          this.handleNode(node, acc)\n        }\n      }\n\n      const sortedRouteNodes = multiSortBy(acc.routeNodes, [\n        (d) => (d.routePath?.includes(`/${rootPathId}`) ? -1 : 1),\n        (d) => d.routePath?.split('/').length,\n        (d) => (d.routePath?.endsWith(this.config.indexToken) ? -1 : 1),\n        (d) => d,\n      ])\n\n      const pluginConfig = plugin.config({\n        generator: this,\n        rootRouteNode,\n        sortedRouteNodes,\n      })\n\n      const routeImports = sortedRouteNodes\n        .filter((d) => !d.isVirtual)\n        .flatMap((node) => getImportForRouteNode(node, exportName) ?? [])\n\n      const hasMatchingRouteFiles =\n        acc.routeNodes.length > 0 || rootRouteNode.exports?.includes(exportName)\n\n      const virtualRouteNodes = sortedRouteNodes\n        .filter((d) => d.isVirtual)\n        .map((node) => {\n          return `const ${\n            node.variableName\n          }${exportName}Import = ${plugin.createVirtualRouteCode({ node })}`\n        })\n      if (\n        !rootRouteNode.exports?.includes(exportName) &&\n        pluginConfig.virtualRootRoute\n      ) {\n        virtualRouteNodes.unshift(\n          `const ${rootRouteNode.variableName}${exportName}Import = ${plugin.createRootRouteCode()}`,\n        )\n      }\n\n      const imports = plugin.imports({\n        sortedRouteNodes,\n        acc,\n        generator: this,\n        rootRouteNode,\n      })\n\n      const routeTreeConfig = buildRouteTreeConfig(\n        acc.routeTree,\n        exportName,\n        this.config.disableTypes,\n      )\n\n      const createUpdateRoutes = sortedRouteNodes.map((node) => {\n        const loaderNode = acc.routePiecesByPath[node.routePath!]?.loader\n        const componentNode = acc.routePiecesByPath[node.routePath!]?.component\n        const errorComponentNode =\n          acc.routePiecesByPath[node.routePath!]?.errorComponent\n        const pendingComponentNode =\n          acc.routePiecesByPath[node.routePath!]?.pendingComponent\n        const lazyComponentNode = acc.routePiecesByPath[node.routePath!]?.lazy\n\n        return [\n          [\n            `const ${node.variableName}${exportName} = ${node.variableName}${exportName}Import.update({\n            ${[\n              `id: '${node.path}'`,\n              !node.isNonPath ? `path: '${node.cleanedPath}'` : undefined,\n              `getParentRoute: () => ${findParent(node, exportName)}`,\n            ]\n              .filter(Boolean)\n              .join(',')}\n          }${this.config.disableTypes ? '' : 'as any'})`,\n            loaderNode\n              ? `.updateLoader({ loader: lazyFn(() => import('./${replaceBackslash(\n                  removeExt(\n                    path.relative(\n                      path.dirname(this.config.generatedRouteTree),\n                      path.resolve(\n                        this.config.routesDirectory,\n                        loaderNode.filePath,\n                      ),\n                    ),\n                    this.config.addExtensions,\n                  ),\n                )}'), 'loader') })`\n              : '',\n            componentNode || errorComponentNode || pendingComponentNode\n              ? `.update({\n                ${(\n                  [\n                    ['component', componentNode],\n                    ['errorComponent', errorComponentNode],\n                    ['pendingComponent', pendingComponentNode],\n                  ] as const\n                )\n                  .filter((d) => d[1])\n                  .map((d) => {\n                    return `${\n                      d[0]\n                    }: lazyRouteComponent(() => import('./${replaceBackslash(\n                      removeExt(\n                        path.relative(\n                          path.dirname(this.config.generatedRouteTree),\n                          path.resolve(\n                            this.config.routesDirectory,\n                            d[1]!.filePath,\n                          ),\n                        ),\n                        this.config.addExtensions,\n                      ),\n                    )}'), '${d[0]}')`\n                  })\n                  .join('\\n,')}\n              })`\n              : '',\n            lazyComponentNode\n              ? `.lazy(() => import('./${replaceBackslash(\n                  removeExt(\n                    path.relative(\n                      path.dirname(this.config.generatedRouteTree),\n                      path.resolve(\n                        this.config.routesDirectory,\n                        lazyComponentNode.filePath,\n                      ),\n                    ),\n                    this.config.addExtensions,\n                  ),\n                )}').then((d) => d.${exportName}))`\n              : '',\n          ].join(''),\n        ].join('\\n\\n')\n      })\n\n      let fileRoutesByPathInterfacePerPlugin = ''\n      let fileRoutesByFullPathPerPlugin = ''\n\n      if (!this.config.disableTypes && hasMatchingRouteFiles) {\n        fileRoutesByFullPathPerPlugin = [\n          `export interface File${exportName}sByFullPath {\n${[...createRouteNodesByFullPath(acc.routeNodes).entries()]\n  .filter(([fullPath]) => fullPath)\n  .map(([fullPath, routeNode]) => {\n    return `'${fullPath}': typeof ${getResolvedRouteNodeVariableName(routeNode, exportName)}`\n  })}\n}`,\n          `export interface File${exportName}sByTo {\n${[...createRouteNodesByTo(acc.routeNodes).entries()]\n  .filter(([to]) => to)\n  .map(([to, routeNode]) => {\n    return `'${to}': typeof ${getResolvedRouteNodeVariableName(routeNode, exportName)}`\n  })}\n}`,\n          `export interface File${exportName}sById {\n'${rootRouteId}': typeof root${exportName}Import,\n${[...createRouteNodesById(acc.routeNodes).entries()].map(([id, routeNode]) => {\n  return `'${id}': typeof ${getResolvedRouteNodeVariableName(routeNode, exportName)}`\n})}\n}`,\n          `export interface File${exportName}Types {\nfile${exportName}sByFullPath: File${exportName}sByFullPath\nfullPaths: ${\n            acc.routeNodes.length > 0\n              ? [...createRouteNodesByFullPath(acc.routeNodes).keys()]\n                  .filter((fullPath) => fullPath)\n                  .map((fullPath) => `'${fullPath}'`)\n                  .join('|')\n              : 'never'\n          }\nfile${exportName}sByTo: File${exportName}sByTo\nto: ${\n            acc.routeNodes.length > 0\n              ? [...createRouteNodesByTo(acc.routeNodes).keys()]\n                  .filter((to) => to)\n                  .map((to) => `'${to}'`)\n                  .join('|')\n              : 'never'\n          }\nid: ${[`'${rootRouteId}'`, ...[...createRouteNodesById(acc.routeNodes).keys()].map((id) => `'${id}'`)].join('|')}\nfile${exportName}sById: File${exportName}sById\n}`,\n          `export interface Root${exportName}Children {\n${acc.routeTree.map((child) => `${child.variableName}${exportName}: typeof ${getResolvedRouteNodeVariableName(child, exportName)}`).join(',')}\n}`,\n        ].join('\\n')\n\n        fileRoutesByPathInterfacePerPlugin = buildFileRoutesByPathInterface({\n          ...plugin.moduleAugmentation({ generator: this }),\n          routeNodes:\n            this.config.verboseFileRoutes !== false\n              ? sortedRouteNodes\n              : [\n                  ...routeFileResult.map(({ node }) => node),\n                  ...sortedRouteNodes.filter((d) => d.isVirtual),\n                ],\n          exportName,\n        })\n      }\n\n      let routeTree = ''\n      if (hasMatchingRouteFiles) {\n        routeTree = [\n          `const root${exportName}Children${this.config.disableTypes ? '' : `: Root${exportName}Children`} = {\n  ${acc.routeTree\n    .map(\n      (child) =>\n        `${child.variableName}${exportName}: ${getResolvedRouteNodeVariableName(child, exportName)}`,\n    )\n    .join(',')}\n}`,\n          `export const ${lowerCaseFirstChar(exportName)}Tree = root${exportName}Import._addFileChildren(root${exportName}Children)${this.config.disableTypes ? '' : `._addFileTypes<File${exportName}Types>()`}`,\n        ].join('\\n')\n      }\n\n      return {\n        routeImports,\n        sortedRouteNodes,\n        acc,\n        virtualRouteNodes,\n        routeTreeConfig,\n        routeTree,\n        imports,\n        createUpdateRoutes,\n        fileRoutesByFullPathPerPlugin,\n        fileRoutesByPathInterfacePerPlugin,\n      }\n    }\n\n    const routeTrees = this.pluginsWithTransform.map((plugin) => ({\n      exportName: plugin.transformPlugin.exportName,\n      ...buildRouteTreeForExport(plugin),\n    }))\n\n    this.plugins.map((plugin) => {\n      return plugin.onRouteTreesChanged?.({\n        routeTrees,\n        rootRouteNode,\n        generator: this,\n      })\n    })\n\n    let mergedImports = mergeImportDeclarations(\n      routeTrees.flatMap((d) => d.imports),\n    )\n    if (this.config.disableTypes) {\n      mergedImports = mergedImports.filter((d) => d.importKind !== 'type')\n    }\n\n    const importStatements = mergedImports.map(buildImportString)\n\n    let moduleAugmentation = ''\n    if (this.config.verboseFileRoutes === false && !this.config.disableTypes) {\n      moduleAugmentation = routeFileResult\n        .map(({ node }) => {\n          const getModuleDeclaration = (routeNode?: RouteNode) => {\n            if (!isRouteNodeValidForAugmentation(routeNode)) {\n              return ''\n            }\n            const moduleAugmentation = this.pluginsWithTransform\n              .map((plugin) => {\n                return plugin.routeModuleAugmentation({\n                  routeNode,\n                })\n              })\n              .filter(Boolean)\n              .join('\\n')\n\n            return `declare module './${this.getImportPath(routeNode)}' {\n                      ${moduleAugmentation}\n                    }`\n          }\n          return getModuleDeclaration(node)\n        })\n        .join('\\n')\n    }\n\n    const routeImports = routeTrees.flatMap((t) => t.routeImports)\n    const rootRouteImports = this.pluginsWithTransform.flatMap(\n      (p) =>\n        getImportForRouteNode(rootRouteNode, p.transformPlugin.exportName) ??\n        [],\n    )\n    if (rootRouteImports.length > 0) {\n      routeImports.unshift(...rootRouteImports)\n    }\n    const routeTreeContent = [\n      ...this.config.routeTreeFileHeader,\n      `// This file was automatically generated by TanStack Router.\n// You should NOT make any changes in this file as it will be overwritten.\n// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.`,\n      [...importStatements].join('\\n'),\n      mergeImportDeclarations(routeImports).map(buildImportString).join('\\n'),\n      routeTrees.flatMap((t) => t.virtualRouteNodes).join('\\n'),\n      routeTrees.flatMap((t) => t.createUpdateRoutes).join('\\n'),\n\n      routeTrees.map((t) => t.fileRoutesByFullPathPerPlugin).join('\\n'),\n      routeTrees.map((t) => t.fileRoutesByPathInterfacePerPlugin).join('\\n'),\n      moduleAugmentation,\n      routeTrees.flatMap((t) => t.routeTreeConfig).join('\\n'),\n      routeTrees.map((t) => t.routeTree).join('\\n'),\n      ...this.config.routeTreeFileFooter,\n    ]\n      .filter(Boolean)\n      .join('\\n\\n')\n    return routeTreeContent\n  }\n\n  private getImportPath(node: RouteNode) {\n    return replaceBackslash(\n      removeExt(\n        path.relative(\n          path.dirname(this.config.generatedRouteTree),\n          path.resolve(this.config.routesDirectory, node.filePath),\n        ),\n        this.config.addExtensions,\n      ),\n    )\n  }\n\n  private async processRouteNodeFile(node: RouteNode): Promise<{\n    shouldWriteTree: boolean\n    cacheEntry: RouteNodeCacheEntry\n    node: RouteNode\n  } | null> {\n    const result = await this.isRouteFileCacheFresh(node)\n\n    if (result.status === 'fresh') {\n      node.exports = result.cacheEntry.exports\n      return {\n        node,\n        shouldWriteTree: result.exportsChanged,\n        cacheEntry: result.cacheEntry,\n      }\n    }\n\n    const existingRouteFile = await this.fs.readFile(node.fullPath)\n    if (existingRouteFile === 'file-not-existing') {\n      throw new Error(`⚠️ File ${node.fullPath} does not exist`)\n    }\n\n    const updatedCacheEntry: RouteNodeCacheEntry = {\n      fileContent: existingRouteFile.fileContent,\n      mtimeMs: existingRouteFile.stat.mtimeMs,\n      exports: [],\n      routeId: node.routePath ?? '$$TSR_NO_ROUTE_PATH_ASSIGNED$$',\n    }\n\n    const escapedRoutePath = node.routePath?.replaceAll('$', '$$') ?? ''\n\n    let shouldWriteRouteFile = false\n    // now we need to either scaffold the file or transform it\n    if (!existingRouteFile.fileContent) {\n      shouldWriteRouteFile = true\n      // Creating a new lazy route file\n      if (node._fsRouteType === 'lazy') {\n        const tLazyRouteTemplate = this.targetTemplate.lazyRoute\n        // Check by default check if the user has a specific lazy route template\n        // If not, check if the user has a route template and use that instead\n        updatedCacheEntry.fileContent = await fillTemplate(\n          this.config,\n          (this.config.customScaffolding?.lazyRouteTemplate ||\n            this.config.customScaffolding?.routeTemplate) ??\n            tLazyRouteTemplate.template(),\n          {\n            tsrImports: tLazyRouteTemplate.imports.tsrImports(),\n            tsrPath: escapedRoutePath.replaceAll(/\\{(.+?)\\}/gm, '$1'),\n            tsrExportStart:\n              tLazyRouteTemplate.imports.tsrExportStart(escapedRoutePath),\n            tsrExportEnd: tLazyRouteTemplate.imports.tsrExportEnd(),\n          },\n        )\n        updatedCacheEntry.exports = ['Route']\n      } else if (\n        // Creating a new normal route file\n        (['layout', 'static'] satisfies Array<FsRouteType>).some(\n          (d) => d === node._fsRouteType,\n        ) ||\n        (\n          [\n            'component',\n            'pendingComponent',\n            'errorComponent',\n            'loader',\n          ] satisfies Array<FsRouteType>\n        ).every((d) => d !== node._fsRouteType)\n      ) {\n        const tRouteTemplate = this.targetTemplate.route\n        updatedCacheEntry.fileContent = await fillTemplate(\n          this.config,\n          this.config.customScaffolding?.routeTemplate ??\n            tRouteTemplate.template(),\n          {\n            tsrImports: tRouteTemplate.imports.tsrImports(),\n            tsrPath: escapedRoutePath.replaceAll(/\\{(.+?)\\}/gm, '$1'),\n            tsrExportStart:\n              tRouteTemplate.imports.tsrExportStart(escapedRoutePath),\n            tsrExportEnd: tRouteTemplate.imports.tsrExportEnd(),\n          },\n        )\n        updatedCacheEntry.exports = ['Route']\n      } else {\n        return null\n      }\n    } else {\n      // transform the file\n      const transformResult = await transform({\n        source: updatedCacheEntry.fileContent,\n        ctx: {\n          target: this.config.target,\n          routeId: escapedRoutePath,\n          lazy: node._fsRouteType === 'lazy',\n          verboseFileRoutes: !(this.config.verboseFileRoutes === false),\n        },\n        plugins: this.transformPlugins,\n      })\n\n      if (transformResult.result === 'error') {\n        throw new Error(\n          `Error transforming route file ${node.fullPath}: ${transformResult.error}`,\n        )\n      }\n      updatedCacheEntry.exports = transformResult.exports\n      if (transformResult.result === 'modified') {\n        updatedCacheEntry.fileContent = transformResult.output\n        shouldWriteRouteFile = true\n      }\n    }\n\n    // file was changed\n    if (shouldWriteRouteFile) {\n      const stats = await this.safeFileWrite({\n        filePath: node.fullPath,\n        newContent: updatedCacheEntry.fileContent,\n        strategy: {\n          type: 'mtime',\n          expectedMtimeMs: updatedCacheEntry.mtimeMs,\n        },\n      })\n      updatedCacheEntry.mtimeMs = stats.mtimeMs\n    }\n\n    this.routeNodeShadowCache.set(node.fullPath, updatedCacheEntry)\n    node.exports = updatedCacheEntry.exports\n    const shouldWriteTree = !deepEqual(\n      result.cacheEntry?.exports,\n      updatedCacheEntry.exports,\n    )\n    return {\n      node,\n      shouldWriteTree,\n      cacheEntry: updatedCacheEntry,\n    }\n  }\n\n  private async didRouteFileChangeComparedToCache(\n    file: {\n      path: string\n      mtimeMs?: bigint\n    },\n    cache: 'routeNodeCache' | 'routeNodeShadowCache',\n  ): Promise<FileCacheChange<RouteNodeCacheEntry>> {\n    const cacheEntry = this[cache].get(file.path)\n    return this.didFileChangeComparedToCache(file, cacheEntry)\n  }\n\n  private async didFileChangeComparedToCache<\n    TCacheEntry extends GeneratorCacheEntry,\n  >(\n    file: {\n      path: string\n      mtimeMs?: bigint\n    },\n    cacheEntry: TCacheEntry | undefined,\n  ): Promise<FileCacheChange<TCacheEntry>> {\n    // for now we rely on the modification time of the file\n    // to determine if the file has changed\n    // we could also compare the file content but this would be slower as we would have to read the file\n\n    if (!cacheEntry) {\n      return { result: 'file-not-in-cache' }\n    }\n    let mtimeMs = file.mtimeMs\n\n    if (mtimeMs === undefined) {\n      try {\n        const currentStat = await this.fs.stat(file.path)\n        mtimeMs = currentStat.mtimeMs\n      } catch {\n        return { result: 'cannot-stat-file' }\n      }\n    }\n    return { result: mtimeMs !== cacheEntry.mtimeMs, mtimeMs, cacheEntry }\n  }\n\n  private async safeFileWrite(opts: {\n    filePath: string\n    newContent: string\n    strategy:\n      | {\n          type: 'mtime'\n          expectedMtimeMs: bigint\n        }\n      | {\n          type: 'new-file'\n        }\n  }) {\n    const tmpPath = this.getTempFileName(opts.filePath)\n    await this.fs.writeFile(tmpPath, opts.newContent)\n\n    if (opts.strategy.type === 'mtime') {\n      const beforeStat = await this.fs.stat(opts.filePath)\n      if (beforeStat.mtimeMs !== opts.strategy.expectedMtimeMs) {\n        throw rerun({\n          msg: `File ${opts.filePath} was modified by another process during processing.`,\n          event: { type: 'update', path: opts.filePath },\n        })\n      }\n      const newFileState = await this.fs.stat(tmpPath)\n      if (newFileState.mode !== beforeStat.mode) {\n        await this.fs.chmod(tmpPath, beforeStat.mode)\n      }\n      if (\n        newFileState.uid !== beforeStat.uid ||\n        newFileState.gid !== beforeStat.gid\n      ) {\n        try {\n          await this.fs.chown(tmpPath, beforeStat.uid, beforeStat.gid)\n        } catch (err) {\n          if (\n            typeof err === 'object' &&\n            err !== null &&\n            'code' in err &&\n            (err as any).code === 'EPERM'\n          ) {\n            console.warn(\n              `[safeFileWrite] chown failed: ${(err as any).message}`,\n            )\n          } else {\n            throw err\n          }\n        }\n      }\n    } else {\n      if (await checkFileExists(opts.filePath)) {\n        throw rerun({\n          msg: `File ${opts.filePath} already exists. Cannot overwrite.`,\n          event: { type: 'update', path: opts.filePath },\n        })\n      }\n    }\n\n    const stat = await this.fs.stat(tmpPath)\n\n    await this.fs.rename(tmpPath, opts.filePath)\n\n    return stat\n  }\n\n  private getTempFileName(filePath: string) {\n    const absPath = path.resolve(filePath)\n    const hash = crypto.createHash('md5').update(absPath).digest('hex')\n    // lazy initialize sessionId to only create tmpDir when it is first needed\n    if (!this.sessionId) {\n      // ensure the directory exists\n      mkdirSync(this.config.tmpDir, { recursive: true })\n      this.sessionId = crypto.randomBytes(4).toString('hex')\n    }\n    return path.join(this.config.tmpDir, `${this.sessionId}-${hash}`)\n  }\n\n  private async isRouteFileCacheFresh(node: RouteNode): Promise<\n    | {\n        status: 'fresh'\n        cacheEntry: RouteNodeCacheEntry\n        exportsChanged: boolean\n      }\n    | { status: 'stale'; cacheEntry?: RouteNodeCacheEntry }\n  > {\n    const fileChangedCache = await this.didRouteFileChangeComparedToCache(\n      { path: node.fullPath },\n      'routeNodeCache',\n    )\n    if (fileChangedCache.result === false) {\n      this.routeNodeShadowCache.set(node.fullPath, fileChangedCache.cacheEntry)\n      return {\n        status: 'fresh',\n        exportsChanged: false,\n        cacheEntry: fileChangedCache.cacheEntry,\n      }\n    }\n    if (fileChangedCache.result === 'cannot-stat-file') {\n      throw new Error(`⚠️ expected route file to exist at ${node.fullPath}`)\n    }\n    const mtimeMs =\n      fileChangedCache.result === true ? fileChangedCache.mtimeMs : undefined\n\n    const shadowCacheFileChange = await this.didRouteFileChangeComparedToCache(\n      { path: node.fullPath, mtimeMs },\n      'routeNodeShadowCache',\n    )\n\n    if (shadowCacheFileChange.result === 'cannot-stat-file') {\n      throw new Error(`⚠️ expected route file to exist at ${node.fullPath}`)\n    }\n\n    if (shadowCacheFileChange.result === false) {\n      // shadow cache has latest file state already\n      // compare shadowCache against cache to determine whether exports changed\n      // if they didn't, cache is fresh\n      if (fileChangedCache.result === true) {\n        if (\n          deepEqual(\n            fileChangedCache.cacheEntry.exports,\n            shadowCacheFileChange.cacheEntry.exports,\n          )\n        ) {\n          return {\n            status: 'fresh',\n            exportsChanged: false,\n            cacheEntry: shadowCacheFileChange.cacheEntry,\n          }\n        }\n        return {\n          status: 'fresh',\n          exportsChanged: true,\n          cacheEntry: shadowCacheFileChange.cacheEntry,\n        }\n      }\n    }\n\n    if (fileChangedCache.result === 'file-not-in-cache') {\n      return {\n        status: 'stale',\n      }\n    }\n    return { status: 'stale', cacheEntry: fileChangedCache.cacheEntry }\n  }\n\n  private async handleRootNode(node: RouteNode) {\n    const result = await this.isRouteFileCacheFresh(node)\n\n    if (result.status === 'fresh') {\n      node.exports = result.cacheEntry.exports\n      this.routeNodeShadowCache.set(node.fullPath, result.cacheEntry)\n      return result.exportsChanged\n    }\n    const rootNodeFile = await this.fs.readFile(node.fullPath)\n    if (rootNodeFile === 'file-not-existing') {\n      throw new Error(`⚠️ expected root route to exist at ${node.fullPath}`)\n    }\n\n    const updatedCacheEntry: RouteNodeCacheEntry = {\n      fileContent: rootNodeFile.fileContent,\n      mtimeMs: rootNodeFile.stat.mtimeMs,\n      exports: [],\n      routeId: node.routePath ?? '$$TSR_NO_ROOT_ROUTE_PATH_ASSIGNED$$',\n    }\n\n    // scaffold the root route\n    if (!rootNodeFile.fileContent) {\n      const rootTemplate = this.targetTemplate.rootRoute\n      const rootRouteContent = await fillTemplate(\n        this.config,\n        rootTemplate.template(),\n        {\n          tsrImports: rootTemplate.imports.tsrImports(),\n          tsrPath: rootPathId,\n          tsrExportStart: rootTemplate.imports.tsrExportStart(),\n          tsrExportEnd: rootTemplate.imports.tsrExportEnd(),\n        },\n      )\n\n      this.logger.log(`🟡 Creating ${node.fullPath}`)\n      const stats = await this.safeFileWrite({\n        filePath: node.fullPath,\n        newContent: rootRouteContent,\n        strategy: {\n          type: 'mtime',\n          expectedMtimeMs: rootNodeFile.stat.mtimeMs,\n        },\n      })\n      updatedCacheEntry.fileContent = rootRouteContent\n      updatedCacheEntry.mtimeMs = stats.mtimeMs\n    }\n\n    const rootRouteExports: Array<string> = []\n    for (const plugin of this.pluginsWithTransform) {\n      const exportName = plugin.transformPlugin.exportName\n      // TODO we need to parse instead of just string match\n      // otherwise a commented out export will still be detected\n      if (rootNodeFile.fileContent.includes(`export const ${exportName}`)) {\n        rootRouteExports.push(exportName)\n      }\n    }\n\n    updatedCacheEntry.exports = rootRouteExports\n    node.exports = rootRouteExports\n    this.routeNodeShadowCache.set(node.fullPath, updatedCacheEntry)\n\n    const shouldWriteTree = !deepEqual(\n      result.cacheEntry?.exports,\n      rootRouteExports,\n    )\n    return shouldWriteTree\n  }\n\n  private handleNode(node: RouteNode, acc: HandleNodeAccumulator) {\n    // Do not remove this as we need to set the lastIndex to 0 as it\n    // is necessary to reset the regex's index when using the global flag\n    // otherwise it might not match the next time it's used\n    resetRegex(this.routeGroupPatternRegex)\n\n    let parentRoute = hasParentRoute(acc.routeNodes, node, node.routePath)\n\n    // if the parent route is a virtual parent route, we need to find the real parent route\n    if (parentRoute?.isVirtualParentRoute && parentRoute.children?.length) {\n      // only if this sub-parent route returns a valid parent route, we use it, if not leave it as it\n      const possibleParentRoute = hasParentRoute(\n        parentRoute.children,\n        node,\n        node.routePath,\n      )\n      if (possibleParentRoute) {\n        parentRoute = possibleParentRoute\n      }\n    }\n\n    if (parentRoute) node.parent = parentRoute\n\n    node.path = determineNodePath(node)\n\n    const trimmedPath = trimPathLeft(node.path ?? '')\n\n    const split = trimmedPath.split('/')\n    const lastRouteSegment = split[split.length - 1] ?? trimmedPath\n\n    node.isNonPath =\n      lastRouteSegment.startsWith('_') ||\n      split.every((part) => this.routeGroupPatternRegex.test(part))\n\n    node.cleanedPath = removeGroups(\n      removeUnderscores(removeLayoutSegments(node.path)) ?? '',\n    )\n\n    if (\n      !node.isVirtual &&\n      (\n        [\n          'lazy',\n          'loader',\n          'component',\n          'pendingComponent',\n          'errorComponent',\n        ] satisfies Array<FsRouteType>\n      ).some((d) => d === node._fsRouteType)\n    ) {\n      acc.routePiecesByPath[node.routePath!] =\n        acc.routePiecesByPath[node.routePath!] || {}\n\n      acc.routePiecesByPath[node.routePath!]![\n        node._fsRouteType === 'lazy'\n          ? 'lazy'\n          : node._fsRouteType === 'loader'\n            ? 'loader'\n            : node._fsRouteType === 'errorComponent'\n              ? 'errorComponent'\n              : node._fsRouteType === 'pendingComponent'\n                ? 'pendingComponent'\n                : 'component'\n      ] = node\n\n      const anchorRoute = acc.routeNodes.find(\n        (d) => d.routePath === node.routePath,\n      )\n\n      if (!anchorRoute) {\n        this.handleNode(\n          {\n            ...node,\n            isVirtual: true,\n            _fsRouteType: 'static',\n          },\n          acc,\n        )\n      }\n      return\n    }\n\n    const cleanedPathIsEmpty = (node.cleanedPath || '').length === 0\n    const nonPathRoute =\n      node._fsRouteType === 'pathless_layout' && node.isNonPath\n\n    node.isVirtualParentRequired =\n      node._fsRouteType === 'pathless_layout' || nonPathRoute\n        ? !cleanedPathIsEmpty\n        : false\n\n    if (!node.isVirtual && node.isVirtualParentRequired) {\n      const parentRoutePath = removeLastSegmentFromPath(node.routePath) || '/'\n      const parentVariableName = routePathToVariable(parentRoutePath)\n\n      const anchorRoute = acc.routeNodes.find(\n        (d) => d.routePath === parentRoutePath,\n      )\n\n      if (!anchorRoute) {\n        const parentNode: RouteNode = {\n          ...node,\n          path: removeLastSegmentFromPath(node.path) || '/',\n          filePath: removeLastSegmentFromPath(node.filePath) || '/',\n          fullPath: removeLastSegmentFromPath(node.fullPath) || '/',\n          routePath: parentRoutePath,\n          variableName: parentVariableName,\n          isVirtual: true,\n          _fsRouteType: 'layout', // layout since this route will wrap other routes\n          isVirtualParentRoute: true,\n          isVirtualParentRequired: false,\n        }\n\n        parentNode.children = parentNode.children ?? []\n        parentNode.children.push(node)\n\n        node.parent = parentNode\n\n        if (node._fsRouteType === 'pathless_layout') {\n          // since `node.path` is used as the `id` on the route definition, we need to update it\n          node.path = determineNodePath(node)\n        }\n\n        this.handleNode(parentNode, acc)\n      } else {\n        anchorRoute.children = anchorRoute.children ?? []\n        anchorRoute.children.push(node)\n\n        node.parent = anchorRoute\n      }\n    }\n\n    if (node.parent) {\n      if (!node.isVirtualParentRequired) {\n        node.parent.children = node.parent.children ?? []\n        node.parent.children.push(node)\n      }\n    } else {\n      acc.routeTree.push(node)\n    }\n\n    acc.routeNodes.push(node)\n  }\n\n  // only process files that are relevant for the route tree generation\n  private isFileRelevantForRouteTreeGeneration(filePath: string): boolean {\n    // the generated route tree file\n    if (filePath === this.generatedRouteTreePath) {\n      return true\n    }\n\n    // files inside the routes folder\n    if (filePath.startsWith(this.routesDirectoryPath)) {\n      return true\n    }\n\n    // the virtual route config file passed into `virtualRouteConfig`\n    if (\n      typeof this.config.virtualRouteConfig === 'string' &&\n      filePath === this.config.virtualRouteConfig\n    ) {\n      return true\n    }\n\n    // this covers all files that are mounted via `virtualRouteConfig` or any `__virtual.ts` files\n    if (this.routeNodeCache.has(filePath)) {\n      return true\n    }\n\n    // virtual config files such as`__virtual.ts`\n    if (isVirtualConfigFile(path.basename(filePath))) {\n      return true\n    }\n\n    // route files inside directories mounted via `physical()` inside a virtual route config\n    if (this.physicalDirectories.some((dir) => filePath.startsWith(dir))) {\n      return true\n    }\n\n    return false\n  }\n}\n"],"names":["virtualGetRouteNodes","physicalGetRouteNodes","_a","routeImports","_b","_c","moduleAugmentation"],"mappings":"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"}